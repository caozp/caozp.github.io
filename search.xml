<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jenkins 声明式pipeline语法整理</title>
    <url>/posts/b9d9f13/</url>
    <content><![CDATA[<h1 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h1><p>顶层必须是pipeline,然后pipeline下面包含的是section。常见的section如下</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent&#123;&#125;</span><br><span class="line">    environment&#123;&#125;</span><br><span class="line">    triggers&#123;&#125;</span><br><span class="line">    options&#123;&#125;</span><br><span class="line">    parameters&#123;&#125;</span><br><span class="line">    tools&#123;&#125;</span><br><span class="line">    stages&#123;&#125;</span><br><span class="line">    post&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="section"><a href="#section" class="headerlink" title="section"></a>section</h1><h2 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h2><p>指定整个流水线或特定阶段将在jenkins环境中执行的位置。</p>
<p>可选值:</p>
<ul>
<li>any 在任何可用的节点上执行。</li>
<li>none 没有指定agent的时候默认。</li>
<li>docker 镜像</li>
<li>label 特定的label名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    //agent any</span><br><span class="line">    //agent &#123; label &#x27;LABEL&#x27;&#125;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123;</span><br><span class="line">            label &#x27;docker&#x27;</span><br><span class="line">            image &#x27;ubuntu:20.04&#x27;</span><br><span class="line">            args &#x27;-u root&#x27;</span><br><span class="line">            alwaysPull false</span><br><span class="line">            registryUrl &#x27;registry.com&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&#x27;build&#x27;) &#123;</span><br><span class="line">            agent &#123; label &#x27;LABEL&#x27; &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;abc&quot;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        stage(&#x27;deploy&#x27;)&#123;</span><br><span class="line">            agent &#123;</span><br><span class="line">                docker &#123;</span><br><span class="line">                    image &#x27;registry.cn-hangzhou.aliyuncs.com/mckj/ansible&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;通过ansbile进行部署&quot;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p>这些阶段根据流水线或阶段的完成情况而 运行(取决于流水线中post部分的位置)</p>
<ul>
<li>success 成功状态会执行</li>
<li>failure 失败状态会执行</li>
<li>always 总是会执行</li>
<li>aborted 中断状态会执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post &#123;</span><br><span class="line">    success &#123;</span><br><span class="line">        sh &quot;echo 成功了&quot;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    always &#123;</span><br><span class="line">        sh &quot;echo always&quot;</span><br><span class="line">        cleanWs()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>为所有步骤设置环境变量，或者是特定阶段的步骤。这取决于 environment 指令在流水线内的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                ACCESS_KEY = credentials(&#x27;my-secret-text&#x27;) </span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;printenv&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该指令还支持一种特殊的辅助方法credentials()。</p>
<p>该方法可用于在Jenkins环境中通过标识符访问预定义的凭证。</p>
<p>支持<strong>Secret Text，Secret Field，Username and password，SSH with Private Key</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                AN_ACCESS_KEY = credentials(&#x27;my-predefined-secret-text&#x27;) </span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;printenv&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&#x27;Example Username/Password&#x27;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                SERVICE_CREDS = credentials(&#x27;my-predefined-username-password&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;Service user is $SERVICE_CREDS_USR&quot;&#x27;</span><br><span class="line">                sh &#x27;echo &quot;Service password is $SERVICE_CREDS_PSW&quot;&#x27;</span><br><span class="line">                sh &#x27;curl -u $SERVICE_CREDS https://myservice.example.com&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&#x27;Example SSH Username with private key&#x27;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                SSH_CREDS = credentials(&#x27;my-predefined-ssh-creds&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;SSH private key is located at $SSH_CREDS&quot;&#x27;</span><br><span class="line">                sh &#x27;echo &quot;SSH user is $SSH_CREDS_USR&quot;&#x27;</span><br><span class="line">                sh &#x27;echo &quot;SSH passphrase is $SSH_CREDS_PSW&quot;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><p>用来配置Jenkins应用自身的一些配置项，常用的参数有如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options &#123;</span><br><span class="line"></span><br><span class="line">    //表示保留10次构建历史</span><br><span class="line">    buildDiscarder(logRotator(numToKeepStr: &#x27;10&#x27;))</span><br><span class="line">    </span><br><span class="line">    //不允许同时执行流水线，被用来防止同时访问共享资源等</span><br><span class="line">    disableConcurrentBuilds()</span><br><span class="line">    </span><br><span class="line">    //项目构建超时时间</span><br><span class="line">    timeout(time: 10, unit: &#x27;MINUTES&#x27;)</span><br><span class="line">    </span><br><span class="line">    //输出构建的时间信息</span><br><span class="line">    timestamps()</span><br><span class="line">    </span><br><span class="line">    //跳过默认的代码检出</span><br><span class="line">    skipDefaultCheckout()</span><br><span class="line">    </span><br><span class="line">    //指定代码检出到$WORKSPACE的子目录</span><br><span class="line">    checkoutToSubdirectory(&#x27;testdir&#x27;)</span><br><span class="line">    </span><br><span class="line">    //重试</span><br><span class="line">    retry(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用于配置stage的指令有retry, timeout, or timestamps</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">    options &#123;</span><br><span class="line">        timeout(time: 1, unit: &#x27;HOURS&#x27;)</span><br><span class="line">        retry(3)</span><br><span class="line">        timestamps()</span><br><span class="line">    &#125;</span><br><span class="line">    steps &#123;</span><br><span class="line">        echo &#x27;Hello World&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Parameters构建变量"><a href="#Parameters构建变量" class="headerlink" title="Parameters构建变量"></a>Parameters构建变量</h2><p>支持的参数</p>
<ul>
<li>text</li>
<li>string</li>
<li>booleanParam</li>
<li>choice</li>
<li>password</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(name: &#x27;PERSON&#x27;, defaultValue: &#x27;Mr Jenkins&#x27;, description: &#x27;Who should I say hello to?&#x27;)</span><br><span class="line"></span><br><span class="line">        text(name: &#x27;BIOGRAPHY&#x27;, defaultValue: &#x27;&#x27;, description: &#x27;Enter some information about the person&#x27;)</span><br><span class="line"></span><br><span class="line">        booleanParam(name: &#x27;TOGGLE&#x27;, defaultValue: true, description: &#x27;Toggle this value&#x27;)</span><br><span class="line"></span><br><span class="line">        choice(name: &#x27;CHOICE&#x27;, choices: [&#x27;One&#x27;, &#x27;Two&#x27;, &#x27;Three&#x27;], description: &#x27;Pick something&#x27;)</span><br><span class="line"></span><br><span class="line">        password(name: &#x27;PASSWORD&#x27;, defaultValue: &#x27;SECRET&#x27;, description: &#x27;Enter a password&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;Hello $&#123;params.PERSON&#125;&quot;</span><br><span class="line"></span><br><span class="line">                echo &quot;Biography: $&#123;params.BIOGRAPHY&#125;&quot;</span><br><span class="line"></span><br><span class="line">                echo &quot;Toggle: $&#123;params.TOGGLE&#125;&quot;</span><br><span class="line"></span><br><span class="line">                echo &quot;Choice: $&#123;params.CHOICE&#125;&quot;</span><br><span class="line"></span><br><span class="line">                echo &quot;Password: $&#123;params.PASSWORD&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="triggers触发器"><a href="#triggers触发器" class="headerlink" title="triggers触发器"></a>triggers触发器</h2><p>定义流水线触发的一些机制与条件，流水线支持的触发器有三种：cron, pollSCM 和 upstream<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">triggers&#123;</span><br><span class="line">   cron(&#x27;H */4 * * 1-5&#x27;) //周一到周五每隔四小时执行构建</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>H关键字，H亦即Hash，表示当前位置跨度范围内随机一值</p>
<p>jenkins定时语法:</p>
<table>
<thead>
<tr>
<th align="left">MINUTE</th>
<th align="left">HOUR</th>
<th align="left">DOM</th>
<th align="left">MONTH</th>
<th align="left">DOW</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Minutes within the hour (0–59)</td>
<td align="left">The hour of the day (0–23)</td>
<td align="left">The day of the month (1–31)</td>
<td align="left">The month (1–12)</td>
<td align="left">The day of the week (0–7) where 0 and 7 are Sunday.</td>
</tr>
</tbody></table>
<ul>
<li>星号:匹配所有值</li>
<li>M-N: 匹配M到N之间的值</li>
<li>M-N&#x2F;X or *&#x2F;X:  范围内X值为步长</li>
<li>A,B: A或者B</li>
</ul>
<h2 id="tools构建工具"><a href="#tools构建工具" class="headerlink" title="tools构建工具"></a>tools构建工具</h2><p>定义部署流程中常用的一些工具，这些工具在管理Jenkins—&gt;Global Tool Configuration中添加，然后在项目中引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven &#x27;maven&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;mvn --version&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h2><p>包含一系列一个或多个 stage 指令</p>
<h3 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h3><p>stage用来描述大部分工作所在的位置</p>
<h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><p>标识阶段之中具体的构建步骤，至少包含一个步骤，<strong>在stage中有且只能有一个steps</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage(&#x27;名称&#x27;)&#123;</span><br><span class="line">    steps&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel并行"><a href="#parallel并行" class="headerlink" title="parallel并行"></a>parallel并行</h3><p>parallel关键字用于指定某些阶段可以并行的情况。一个阶段必须只有一个 steps 或 parallel 的阶段</p>
<p>通过添加 failFast true 到包含 parallel的 stage 中， 当其中一个进程失败时，你可以强制所有的 parallel 阶段都被终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent none</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;clean&#x27;) &#123;</span><br><span class="line">            failFast true</span><br><span class="line">            parallel&#123;</span><br><span class="line">                stage(&#x27;Node_1&#x27;)&#123;</span><br><span class="line">                    agent &#123; label &#x27;Node_1&#x27; &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                      sh &#x27;echo &quot;task1&quot;&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                stage(&#x27;Node_2&#x27;) &#123;</span><br><span class="line">                    agent &#123; label &#x27;Node_2&#x27; &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                       sh &#x27;echo &quot;task2&quot;&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令when"><a href="#指令when" class="headerlink" title="指令when"></a>指令when</h3><p>允许流水线根据指定条件来确定是否执行该阶段</p>
<ol>
<li><p>branch 当正在构建的分支与给定的分支模式（ANT 样式路径 glob）匹配时执行该阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when &#123; branch &#x27;master&#x27; &#125;</span><br><span class="line">可选参数比较器</span><br><span class="line">when &#123; </span><br><span class="line">    branch pattern: &quot;release-\\d+&quot;, comparator: &quot;REGEXP&quot;</span><br><span class="line"></span><br><span class="line">    branch pattern: &quot;release-*&quot;, comparator: &quot;GLOB&quot; //Ant风格路径</span><br><span class="line"></span><br><span class="line">    branch pattern: &quot;release&quot;, comparator: &quot;EQUALS&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>environment 当指定的环境变量设置为给定值时执行该阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">    when &#123;</span><br><span class="line">        branch &#x27;production&#x27;</span><br><span class="line">        environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;production&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    steps &#123;</span><br><span class="line">        echo &#x27;Deploying&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>equals 当期望值等于实际值时执行阶段，例如：when { equals expected: 2, actual: currentBuild.number }</p>
</li>
<li><p>not 当嵌套条件为假时执行该阶段。 必须包含一个条件。例如：when { not { branch ‘master’ } }</p>
</li>
<li><p>expression 当指定的 Groovy 表达式计算结果为真时执行该阶段，例如：when { expression { return params.DEBUG_BUILD } } 。请注意，当从表达式返回字符串时，它们必须转换为布尔值或返回空值以计算结果为假。</p>
</li>
<li><p>allOf,anyOf 当一个或者多个条件为真时 如when { anyOf { branch ‘master’; branch ‘staging’ } }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">    when &#123;</span><br><span class="line">        branch &#x27;production&#x27;</span><br><span class="line">        anyOf &#123;</span><br><span class="line">            environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;production&#x27;</span><br><span class="line">            environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;staging&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    steps &#123;</span><br><span class="line">        echo &#x27;Deploying&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>triggeredBy 根据触发原因</p>
</li>
</ol>
<ul>
<li>when { triggeredBy ‘SCMTrigger’ }</li>
<li>when { triggeredBy ‘TimerTrigger’ }</li>
<li>when { triggeredBy ‘BuildUpstreamCause’ }</li>
<li>when { triggeredBy cause: “UserIdCause”, detail: “vlinde” }</li>
</ul>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo使用以及next主题配置</title>
    <url>/posts/177574ba/</url>
    <content><![CDATA[<p>参考<a href="https://blog.csdn.net/as480133937/article/details/100138838">文章</a></p>
<span id="more"></span>
<p>添加了本地搜索<br>修改文章链接<br>添加live2d</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>hexo new “name”       # 新建文章<br>hexo new page “name”  # 新建页面<br>hexo g                # 生成页面<br>hexo d                # 部署<br>hexo g -d             # 生成页面并部署<br>hexo s                # 本地预览<br>hexo clean            # 清除缓存和已生成的静态文件<br>hexo help             # 帮助</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>shell脚本基础知识点</title>
    <url>/posts/acba6a0c/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>shell变量定义要求:</p>
<ul>
<li>首个字符必须为字母</li>
<li>中间不能有空格，可以使用下划线，<strong>等号左右也不能有空格</strong></li>
<li>不能使用标点符号</li>
<li>不能使用bash里的关键字</li>
</ul>
<span id="more"></span>

<p>访问:在 Shell 中，访问变量的值,需要使用 $ 符号加上变量名即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_var=&quot;this is a new line&quot;</span><br><span class="line">echo $your_var</span><br><span class="line">echo $&#123;your_var&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个变量未设置，那么就使用默认值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;parameter-default&#125; 或者 <span class="variable">$&#123;parameter:-default&#125;</span></span></span><br><span class="line"></span><br><span class="line">default=$&#123;HOME-`whoami`&#125;</span><br><span class="line">echo $default</span><br></pre></td></tr></table></figure>

<h2 id="只读变量readonly"><a href="#只读变量readonly" class="headerlink" title="只读变量readonly"></a>只读变量readonly</h2><p>在变量前加上readonly，变量不可以被重新赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readonly github</span><br><span class="line">github=&quot;https://www.github.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="删除变量unset"><a href="#删除变量unset" class="headerlink" title="删除变量unset"></a>删除变量unset</h2><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var=&quot;abc&quot;</span><br><span class="line">unset var</span><br><span class="line">echo $var  # unset后的变量,再次访问就为空</span><br></pre></td></tr></table></figure>

<h2 id="命令结果赋值给变量"><a href="#命令结果赋值给变量" class="headerlink" title="命令结果赋值给变量"></a>命令结果赋值给变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variable=`command`</span><br><span class="line">variable=$(command)</span><br></pre></td></tr></table></figure>
<p>例子1.获取远程的所有分支名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">REMOTE_BRANCHES=$(git branch -r)</span><br><span class="line">for remote_branch in $&#123;REMOTE_BRANCHES[*]&#125;</span><br><span class="line">do</span><br><span class="line">  echo $&#123;remote_branch&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例子2.获取当前的分支名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Default_Branch=$(git rev-parse --abbrev-ref HEAD)</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>使用单引号和使用双引号也是有区别的。<strong>单引号不会转义，原样输出; 双引号会读取变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">字符串为双引号时</span><br><span class="line">export STRING=&quot;$HOME&quot;</span><br><span class="line">echo &#x27;$STRING&#x27;    -&gt; $STRING</span><br><span class="line">export STRING=&quot;$HOME&quot;</span><br><span class="line">echo &quot;$STRING&quot;    -&gt; /home/apple</span><br><span class="line"></span><br><span class="line">字符串为单引号时</span><br><span class="line">export STRING=&#x27;$HOME&#x27;</span><br><span class="line">echo &#x27;$STRING&#x27;    -&gt; $STRING</span><br><span class="line">export STRING=&#x27;$HOME&#x27;</span><br><span class="line">echo &quot;$STRING&quot;    -&gt; $HOME</span><br></pre></td></tr></table></figure>

<h2 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h2><p>在Shell中，转义字符是一个特殊字符，用于表示一些特殊的含义。例如插入换行符、制表符、引号等。在Shell命令中，可以使用<strong>反斜杠</strong>来指示后面的字符应该被当做普通字符处理，而不是具有特殊含义。</p>
<p>以下是一些常见的转义字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\n：表示换行符，用于在字符串中插入一个新行。</span><br><span class="line">\t：表示制表符，用于在字符串中插入一个制表符。</span><br><span class="line">\&quot;：表示双引号，用于在字符串中插入一个双引号。</span><br><span class="line">\&#x27;：表示单引号，用于在字符串中插入一个单引号。</span><br><span class="line">\\：表示反斜杠，用于在字符串中插入一个反斜杠。</span><br></pre></td></tr></table></figure>
<p>例如，如果我们想在一个字符串中插入一个双引号，可以使用转义字符\来表示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export STRING=&quot;\&quot;hello\&quot; world&quot;</span><br><span class="line">echo $STRING    </span><br><span class="line">&quot;hello&quot; world</span><br></pre></td></tr></table></figure>
<p>又或者，我们想在字符串中加入换行符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STRING=&quot;hello\n world&quot;</span><br><span class="line">-&gt; % echo $STRING</span><br><span class="line">hello</span><br><span class="line"> world</span><br></pre></td></tr></table></figure>

<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#var&#125; 可以表示字符串长度，也就是字符的个数</span></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% string=<span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span></span></span><br><span class="line">10 </span><br></pre></td></tr></table></figure>

<h2 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h2><h3 id="按下标切割"><a href="#按下标切割" class="headerlink" title="按下标切割"></a>按下标切割</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string: start&#125;</span>        </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string: start :length&#125;</span> </span><br><span class="line">start -- 起始位置，从左边开始，字符串第一个索引是0</span><br><span class="line">length -- 长度。没有length的时候，默认到结尾</span><br></pre></td></tr></table></figure>
<p>从第二个字符截取到结尾</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;This is a line&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string:2&#125;        -&gt;  is is a line</span></span><br></pre></td></tr></table></figure>
<p>从第二个字符截取4个字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;This is a line&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string:2:4&#125;        -&gt;  is i</span></span><br></pre></td></tr></table></figure>
<p><strong>也可以从右边下标开始计数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string: 0-start :length&#125;</span></span><br></pre></td></tr></table></figure>
<p>从右边开始计数时，起始下标数字是 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % string=&quot;This is a line&quot;</span><br><span class="line"></span><br><span class="line">-&gt; % echo $&#123;string:0-4&#125;</span><br><span class="line">line   # 表示截取最末尾四个字符</span><br><span class="line">-&gt; % echo $&#123;string:0-4:2&#125;</span><br><span class="line">li</span><br><span class="line">-&gt; % echo $&#123;string:0-1&#125;</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<h3 id="匹配Pattern切割"><a href="#匹配Pattern切割" class="headerlink" title="匹配Pattern切割"></a>匹配Pattern切割</h3><p>${var#Pattern}, ${var##Pattern}：删除从$var前端开始的最短或最长匹配Pattern的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;string#*chars&#125; </span><br><span class="line">从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符</span><br><span class="line"></span><br><span class="line">$&#123;string##*chars&#125; </span><br><span class="line">从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</span><br><span class="line"></span><br><span class="line">$&#123;string%chars*&#125;  </span><br><span class="line">从 string 字符串第一次出现 *chars 的位置开始，截取 chars 左边的所有字符。</span><br><span class="line"></span><br><span class="line">$&#123;string%%chars*&#125; </span><br><span class="line">从 string 字符串最后一次出现 *chars 的位置开始，截取 chars 左边的所有字符。</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例，按 _ 分割</span><br><span class="line">var=1_2_3_4_5</span><br><span class="line"></span><br><span class="line">echo $&#123;var#*_&#125;    结果为2_3_4_5  去掉 从左边开始 到第一个字符 &#x27;_&#x27; 之间的内容</span><br><span class="line"></span><br><span class="line">echo $&#123;var##*_&#125;   结果为5        去掉 从左边开始 到最后一个字符 &#x27;_&#x27; 之间的内容</span><br><span class="line"></span><br><span class="line">echo $&#123;var%_*&#125;    结果为1_2_3_4  去掉 从右边开始 到第一个字符 &#x27;_&#x27; 之间的内容</span><br><span class="line"></span><br><span class="line">echo $&#123;var%%_*&#125;   结果为1        去掉 从右边开始 到最后一个字符 &#x27;_&#x27; 之间的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">练习:</span><br><span class="line">file=a/b/c/d/e</span><br><span class="line">echo $&#123;file##*/&#125;</span><br><span class="line">echo $&#123;file#*/&#125;</span><br><span class="line">echo $&#123;file%%/*&#125;</span><br><span class="line">echo $&#123;file%/*&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cut切割"><a href="#cut切割" class="headerlink" title="cut切割"></a>cut切割</h3><p>案例1，使用cut命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; cat /etc/passwd|head -n 5|cut -d : -f 1|sed -n &quot;1p&quot;</span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<h3 id="awk切割"><a href="#awk切割" class="headerlink" title="awk切割"></a>awk切割</h3><p>案例1，使用awk命令,根据github pr获取pr对应的改动文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Accept: application/vnd.github+json&quot; -H &quot;Authorization: Bearer $1&quot; https://url/pulls/$2/files | grep &#x27;&quot;filename&quot;:&#x27;|awk -F &#x27;&quot;&#x27; &#x27;&#123;print $4&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var=$(cat &lt;&lt;- EOF</span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line">echo &quot;$var&quot;  # 此处一定要加引号，否则只会单行显示</span><br><span class="line"></span><br><span class="line">#生成json数据后，通过post命令请求url</span><br><span class="line">generate_post_data()</span><br><span class="line">&#123;</span><br><span class="line">cat &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">&quot;tag_name&quot;: &quot;$tag&quot;,</span><br><span class="line">&quot;target_commitish&quot;: &quot;$branch&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line">curl -H &quot;$AUTH&quot; -H &quot;Content-Type: application/json&quot; --request POST --data &quot;$(generate_post_data)&quot; &quot;https://github.com/api/v3/repos/$owner/$repo/releases&quot;</span><br></pre></td></tr></table></figure>
<p>EOF是“End Of File”的缩写，表示文件结束的标记。在Shell中，EOF通常用于指定一个多行输入的结束标记，例如在输入脚本或命令时。</p>
<p>在Shell中，EOF后面的文本会被视为输入的内容，直到遇到一个与EOF内容相同的行为止。这个标记通常用于输入多行文本，例如在创建一个新文件时，需要输入文件内容，可以使用EOF来指定输入的结束标记。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>用括号来表示数组，数组元素用”<strong>空格</strong>“符号分割开</p>
<p>array&#x3D;(v1 v2 v3 v4)</p>
<p>读取某个元素: ${数组名[下标]}</p>
<p>使用 @ 符号可以获取数组中的所有元素: ${array[@]}</p>
<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>我们要获取数组的长度，<strong>我们需要使用 @ 或者 * 将数组扩展成列表，然后再次使用 # 获取数组的长度。</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;#array_name[@]&#125;</span><br><span class="line">$&#123;#array_name[*]&#125;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % array=(a b c d e f)</span><br><span class="line">-&gt; % echo $&#123;array[3]&#125;       </span><br><span class="line">d</span><br><span class="line">-&gt; % echo $&#123;array[@]&#125;       </span><br><span class="line">a b c d e f</span><br><span class="line">-&gt; % echo $&#123;#array[@]&#125;</span><br><span class="line">6</span><br><span class="line">-&gt; % echo $&#123;#array[*]&#125;</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了管道</p>
<p>Linux 管道使用竖线|连接多个命令，这被称为管道符。Linux 管道的具体语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 [ | commandN... ]</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -al|grep file</span><br></pre></td></tr></table></figure>

<p>使用xargs占位符, 找到文件中的minSdkVersion并替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;minSdkVersion&#x27; build.gradle |xargs -I &#123;&#125; sed -i &quot;s/&#123;&#125;/minSdkVersion 23/g&quot; build.gradle</span><br></pre></td></tr></table></figure>

<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>重定向操作符&gt;将命令与文件连接起来，用文件来接收命令的输出；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command &gt; file</span><br></pre></td></tr></table></figure>
<p>在输出重定向中，&gt;代表的是覆盖，&gt;&gt;代表的是追加。</p>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 &lt; input.txt | command2</span><br></pre></td></tr></table></figure>
<p>示例:使用 tr 命令从 os.txt 文件中获取输入，然后通过管道将输出发送给 sort 或 uniq 等命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; $ cat os.txt</span><br><span class="line">redhat</span><br><span class="line">suse</span><br><span class="line">centos</span><br><span class="line">ubuntu</span><br><span class="line">solaris</span><br><span class="line">hp-ux</span><br><span class="line">fedora</span><br><span class="line">centos</span><br><span class="line">redhat</span><br><span class="line">hp-ux</span><br><span class="line">-&gt; $ tr a-z A-Z &lt;os.txt | sort</span><br><span class="line">CENTOS</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br><span class="line">-&gt; $ tr a-z A-Z &lt;os.txt | sort | uniq</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br></pre></td></tr></table></figure>

<h2 id="标准错误与标准输出"><a href="#标准错误与标准输出" class="headerlink" title="标准错误与标准输出"></a>标准错误与标准输出</h2><p>Linux 程序在执行任何形式的 I&#x2F;O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。</p>
<p>stdin(0)、stdout(1)、stderr(2) 默认都是打开的，在重定向的过程中，0、1、2 这三个文件描述符可以直接使用。</p>
<h3 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; $ ls java  #先预览一下错误信息</span><br><span class="line">ls: 无法访问java: 没有那个文件或目录</span><br><span class="line">-&gt; $ ls java 2&gt;err.log  #重定向</span><br><span class="line">-&gt; $ cat err.log  #查看文件</span><br><span class="line">ls: 无法访问java: 没有那个文件或目录</span><br></pre></td></tr></table></figure>

<h3 id="同时保存标准输出和标准输入"><a href="#同时保存标准输出和标准输入" class="headerlink" title="同时保存标准输出和标准输入"></a>同时保存标准输出和标准输入</h3><p>2&gt;&amp;1, 表示2的输出重定向等同于1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls java &gt;out.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h3 id="什么是-dev-null"><a href="#什么是-dev-null" class="headerlink" title="什么是&#x2F;dev&#x2F;null"></a>什么是&#x2F;dev&#x2F;null</h3><p>&#x2F;dev&#x2F;null表示空设备，在Unix和类Unix系统中使用。它被用作一个虚拟的黑洞，任何写入&#x2F;dev&#x2F;null的数据都会被丢弃，任何从&#x2F;dev&#x2F;null读取的操作都会立即返回一个空值。因此，&#x2F;dev&#x2F;null经常被用来丢弃不需要的输出或者作为一个空的输入源</p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>Shell 变量的作用域可以分为三种：</p>
<ul>
<li>全局变量：当前 shell 进程中使用的变量，无前缀词修饰直接赋值的变量，如 FOO&#x3D;bar</li>
<li>环境变量：可以在子shell中使用的变量，使用 export 导出，如 export FOO&#x3D;bar</li>
<li>局部变量：使用 local 修饰，只能在函数内部使用。</li>
</ul>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% AGE=10</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">echo</span> <span class="variable">$AGE</span></span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>此时AGE是全局变量，而且，在子shell中也无法获取它的数值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % zsh              #zsh可以切换到子shell</span><br><span class="line">-&gt; % echo $AGE        #此时为空值</span><br><span class="line"></span><br><span class="line">#执行脚本也无法读到变量</span><br><span class="line">-&gt; % cat test.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo $AGE</span><br><span class="line"></span><br><span class="line">-&gt; % ./test.sh</span><br><span class="line">   #无结果</span><br></pre></td></tr></table></figure>
<p>我们看到，此时并没有获取到该变量的值。即，<strong>全局变量只能在当前 Shell 访问</strong></p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>要想变量的作用域仅限于函数内部，那么可以在定义时加上 local 命令，此时该变量就成了局部变量</p>
<p>新建一个脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义函数</span></span><br><span class="line">function func()&#123;</span><br><span class="line">	a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出函数内部的变量</span></span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<p>此时a输出为99。修改脚本,为变量a添加local修饰</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义函数</span></span><br><span class="line">function func()&#123;</span><br><span class="line">	local a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出函数内部的变量</span></span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<p>则此时a为空值</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>如果使用 export 命令将变量导出，那么它就在所有的子 Shell 中也有效了，这称为 “环境变量”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">export</span> AGE=10</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">cat</span> test.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $AGE</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% ./test.sh</span></span><br><span class="line">10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% zsh</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">echo</span> <span class="variable">$AGE</span></span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h2 id="系统环境变量"><a href="#系统环境变量" class="headerlink" title="系统环境变量"></a>系统环境变量</h2><p>我们可以通过<code>env</code>命令和<code>set</code>命令查看一些当前shell中存在的变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set 可以查看环境变量</span><br><span class="line">env 可以查看所有变量</span><br></pre></td></tr></table></figure>
<p>这其中有一些比较特殊的变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">OSTYPE    <span class="comment">#操作系统类型 x86_64</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">MACHTYPE  <span class="comment">#机器类型，识别系统的硬件类型。 如 darwin22.0</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PPID      <span class="comment">#一个进程的$PPID变量保存它的父进程的进程ID(pid)。</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">UID       <span class="comment">#用户ID号，这是当前用户的用户标识号，它在/etc/passwd文件中记录。或者(id -u)</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">USER</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PWD</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">LANG      <span class="comment">#默认的主语系变量  查看所有支持的语言-&gt;locale -a</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL     <span class="comment">#可以通过 cat /etc/shells  查看支持解释器</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PATH</span>      </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PS1      命令提示符设置。也就是[root@localhost ~ ]的设置。对于root用户是<span class="comment">#，对于普通用户是$</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">? 上个命令的退出状态，或函数的返回值。</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>shell 是指一个面向用户的命令接口，表现形式就是一个可以由用户录入的界面，这个界面也可以反馈运行信息</p>
<h2 id="查看当前shell"><a href="#查看当前shell" class="headerlink" title="查看当前shell"></a>查看当前shell</h2><p>在linux机器上，默认都是使用bash。而在mac机器上，默认的是zsh。</p>
<p>查看支持的shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">cat</span> /etc/shells</span></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看默认的shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % echo $SHELL</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure>
<h2 id="login-shell与非login-Shell"><a href="#login-shell与非login-Shell" class="headerlink" title="login shell与非login Shell"></a>login shell与非login Shell</h2><h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>包含两种情况：</p>
<ol>
<li>直接通过终端输入帐号密码登录,或者ssh连接</li>
<li>使用 <code>su - username</code> 切换的用户</li>
</ol>
<p>登录式shell的配置文件以 <code>/etc/profile</code> 为入口，然后嵌套引入其他配置文件。<br><strong>常见的加载顺序</strong>通常为</p>
<ol>
<li>&#x2F;etc&#x2F;profile</li>
<li>&#x2F;etc&#x2F;bash.bashrc</li>
<li>~&#x2F;.bash_profile</li>
<li>~&#x2F;.bashrc</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在mac机器上准备两个文件，设置两个环境变量，然后远程ssh登陆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File1: .zprofile:</span><br><span class="line">export http_proxy=zprofile</span><br><span class="line">export AGE=20</span><br><span class="line"></span><br><span class="line">File2: .zshrc:</span><br><span class="line">export http_proxy=internet.com</span><br></pre></td></tr></table></figure>
<p>执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % echo $0</span><br><span class="line">-zsh    # 前面的 - 表示是login shell</span><br><span class="line">-&gt; % echo $AGE</span><br><span class="line">20</span><br><span class="line">-&gt; % echo $http_proxy</span><br><span class="line">http://internet.com</span><br></pre></td></tr></table></figure>
<p>可以看到，.zshrc中的http_proxy变量值覆盖了.zprofile的变量http_proxy值。得出.zshrc比.zprofile后加载</p>
<h3 id="非登陆式shell"><a href="#非登陆式shell" class="headerlink" title="非登陆式shell"></a>非登陆式shell</h3><p>包含这几种情况：</p>
<ol>
<li>su username</li>
<li>图形界面下打开的终端</li>
<li>执行脚本</li>
<li>其他任何bash实例</li>
</ol>
<p>通常的加载顺序为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.bashrc -&gt; /etc/bashrc -&gt; /etc/profile.d/*.sh</span><br></pre></td></tr></table></figure>

<h2 id="父shell与子shell"><a href="#父shell与子shell" class="headerlink" title="父shell与子shell"></a>父shell与子shell</h2><p>当在执行一个脚本时，父Shell会根据脚本程序的第一行 <code>#!</code> 之后指定的解释器开启一个 子Shell 环境，然后在子Shell中执行此脚本。<br>但是一旦，子Shell 中的脚本执行完毕，此子Shell随即结束，回到父Shell中，不会影响父Shell原本的环境。<br>也就是说export一个变量后，父shell是不会读取到该变量</p>
<h3 id="如何判断父shell与子shell"><a href="#如何判断父shell与子shell" class="headerlink" title="如何判断父shell与子shell?"></a>如何判断父shell与子shell?</h3><p>通过进程ID，执行ps -f</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ps -f</span><br><span class="line">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class="line">  501 14251 14250   0  3:25下午 ttys000    0:00.53 -zsh</span><br><span class="line">-&gt; % zsh                 # 可以通过这种方式开启一个子shell</span><br><span class="line">-&gt; % ps -f</span><br><span class="line">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class="line">  501 14251 14250   0  3:25下午 ttys000    0:00.53 -zsh</span><br><span class="line">  501 14448 14251   0  3:32下午 ttys000    0:00.20 zsh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; PS 命令:</span><br><span class="line">&gt; UID 程序被该UID所拥有</span><br><span class="line">&gt; PID 代表这个程序的ID</span><br><span class="line">&gt; PPID 代表其上级父程序的ID</span><br></pre></td></tr></table></figure>
<p>由上可以看到子shell还是一个非login shell</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title>如何写一个shell脚本</title>
    <url>/posts/5b59793/</url>
    <content><![CDATA[<h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><p>用户事先编写一个 sh 脚本文件，内含 shell 脚本，而后使用 shell 程序执行该脚本，这种方式，我们习惯称为 shell 编程。</p>
<p>shell 脚本中包含一些编程元素：</p>
<ul>
<li>if…else 选择结构，case…in 开关语句，for、while、until 循环；</li>
<li>变量、数组、字符串、注释、加减乘除、逻辑运算等概念；</li>
<li>函数，包括用户自定义的函数和内置函数</li>
</ul>
<span id="more"></span>
<h1 id="脚本的参数"><a href="#脚本的参数" class="headerlink" title="脚本的参数"></a>脚本的参数</h1><p>运行脚本，可以添加参数。这些参数在脚本文件内部可以使用 <code>$n</code> 的形式来接收。例如，<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td align="left">脚本名</td>
</tr>
<tr>
<td align="left">$n</td>
<td align="left">位置参数</td>
</tr>
<tr>
<td align="left">$#</td>
<td align="left">传递给脚本的参数个数</td>
</tr>
<tr>
<td align="left">$*</td>
<td align="left">传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td align="left">$@</td>
<td align="left">传递给脚本或函数的所有参数。当被双引号包含时，与上面稍有不同</td>
</tr>
</tbody></table>
<h3 id="和-的差别"><a href="#和-的差别" class="headerlink" title="$*和$@的差别"></a>$*和$@的差别</h3><p>$*和 $@ 都表示传递给函数或脚本的所有参数。<br>但是当它们被双引号” “包含时，就会有区别了：</p>
<ul>
<li>“$*”会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。</li>
<li>“$@”仍然将每个参数都看作一份数据，彼此之间是独立的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;print each param from \&quot;\$*\&quot;&quot;</span><br><span class="line">for var in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;$var&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;print each param from \&quot;\$@\&quot;&quot;</span><br><span class="line">for var in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;$var&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">$ ./test.sh a b c d</span><br><span class="line">print each param from &quot;$*&quot;</span><br><span class="line">a b c d</span><br><span class="line">print each param from &quot;$@&quot;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p>对于$*，只循环了 1 次，因为它只有 1 份数据；<br>对于$@，循环了 5 次，因为它有 5 份数据</p>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>我们可以检查对参数个数进行检查，如果脚本的参数个数不达标则报错退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $# -ne 2 ];then</span><br><span class="line">   echo &quot;error:****&quot;</span><br><span class="line">   exit -1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>也可以用可选参数方式对部分变量赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TAG=default-tag</span><br><span class="line">BRANCH=default-branch</span><br><span class="line">REPO=default-repo</span><br><span class="line"></span><br><span class="line">while [ &quot;$1&quot; != &quot;&quot; ]; do</span><br><span class="line">  case $1 in</span><br><span class="line">    -r)</span><br><span class="line">      shift</span><br><span class="line">      REPO=$1</span><br><span class="line">      ;;</span><br><span class="line">    -b)</span><br><span class="line">      shift</span><br><span class="line">      BRANCH=$1</span><br><span class="line">      ;;</span><br><span class="line">    -t)</span><br><span class="line">      shift</span><br><span class="line">      TAG=$1</span><br><span class="line">      ;;</span><br><span class="line">    *)</span><br><span class="line">      echo &gt;&amp;2 &quot;Usage2: $0 -r [value] -b [value] -t [value]&quot;</span><br><span class="line">      exit 1</span><br><span class="line">      ;;</span><br><span class="line">  esac</span><br><span class="line">  shift</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $TAG</span><br><span class="line">echo $BRANCH</span><br><span class="line">echo $REPO</span><br></pre></td></tr></table></figure>
<p>此处，<code>shift</code>命令用于向左移动脚本的参数位置。每次调用<code>shift</code>命令，脚本的参数位置都会向左移动一个位置，原来的 <code>$2</code> 变成<code>$1</code>，<code>$3</code>变成<code>$2</code>，依此类推。这在处理脚本的命令行参数时特别有用</p>
<h1 id="设置shell特性"><a href="#设置shell特性" class="headerlink" title="设置shell特性"></a>设置shell特性</h1><p>用set命令设置shell的特性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -x</span><br></pre></td></tr></table></figure>
<h3 id="e-表示shell脚本有错误立刻退出"><a href="#e-表示shell脚本有错误立刻退出" class="headerlink" title="-e 表示shell脚本有错误立刻退出"></a>-e 表示shell脚本有错误立刻退出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -e</span><br><span class="line">cd aaa</span><br><span class="line">ls</span><br><span class="line">echo &quot;end&quot;</span><br></pre></td></tr></table></figure>
<p>此处没有aaa目录，shell脚本会终止在第三行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/test.sh: line 3: cd: aaa: No such file or directory</span><br></pre></td></tr></table></figure>

<h3 id="u-表示shell会将unset的，或者为空的变量视为错误并退出"><a href="#u-表示shell会将unset的，或者为空的变量视为错误并退出" class="headerlink" title="-u 表示shell会将unset的，或者为空的变量视为错误并退出"></a>-u 表示shell会将unset的，或者为空的变量视为错误并退出</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -u</span><br><span class="line">echo $PATH</span><br><span class="line">echo $TOKEN     # ./test.sh: line 4: TOKEN: unbound variable</span><br><span class="line">ls</span><br><span class="line">echo &quot;end&quot;</span><br></pre></td></tr></table></figure>

<h3 id="x-表示调试模式，执行的每一命令都打印上"><a href="#x-表示调试模式，执行的每一命令都打印上" class="headerlink" title="-x 表示调试模式，执行的每一命令都打印上"></a>-x 表示调试模式，执行的每一命令都打印上</h3><h1 id="脚本函数"><a href="#脚本函数" class="headerlink" title="脚本函数"></a>脚本函数</h1><p>在Shell脚本中，可以使用function关键字来定义函数。以下是一个简单的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say_hello() &#123;</span><br><span class="line">    echo &quot;Hello, world!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">say_hello</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了一个名为say_hello的函数，函数体中使用echo语句输出字符串Hello, world!。在函数定义后，使用函数名来调用函数，例如say_hello。</p>
<p>如果函数需要传递参数，则可以在函数名后面添加参数列表。以下是一个带参数的函数示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say_hello_to() &#123;</span><br><span class="line">    echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">say_hello_to &quot;John&quot;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了一个名为say_hello_to的函数，并在函数名后面添加了参数列表。函数体中使用echo语句输出字符串Hello, <code>$1</code>!，其中$1表示第一个参数的值。在函数调用时，将要传递的参数作为参数列表的值传递给函数，例如say_hello_to “John”。</p>
<p>除了使用function关键字来定义函数之外，还可以使用函数简写语法来定义函数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">say_hello() &#123;</span><br><span class="line">    echo &quot;Hello, world!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">say_hello</span><br></pre></td></tr></table></figure>

<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>在Shell脚本中，可以使用return语句来返回函数的值。以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    local sum=$(($1 + $2))</span><br><span class="line">    return $sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数并获取返回值</span><br><span class="line">add 10 20</span><br><span class="line">result=$?</span><br><span class="line"></span><br><span class="line">echo &quot;The sum is: $result&quot;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了一个名为add的函数，函数体中计算两个参数的和并将结果保存在变量sum中。使用return语句将变量sum的值作为函数返回值。在函数调用时，将要传递的参数作为参数列表的值传递给函数，例如add 10 20。使用$?来获取函数的返回值，将其保存在变量result中，并使用echo语句输出返回值。</p>
<p>注意，在Shell脚本中，函数的返回值只能是一个整数值。如果需要返回其他类型的值（如字符串），可以将其保存在一个变量中，并在函数结束时输出该变量的值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function get_greeting() &#123;</span><br><span class="line">    local name=$1</span><br><span class="line">    local greeting=&quot;Hello, $name!&quot;</span><br><span class="line">    echo $greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数并获取返回值</span><br><span class="line">result=$(get_greeting &quot;John&quot;)</span><br><span class="line">echo $result</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了一个名为get_greeting的函数，函数体中使用参数name构建问候语，并将其保存在变量greeting中。在函数结束时，使用echo语句输出变量greeting的值。在函数调用时，将要传递的参数作为参数列表的值传递给函数，例如get_greeting “John”。将函数的输出保存在变量result中，并使用echo语句输出返回值。</p>
<h1 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h1><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td><code>**</code></td>
<td>求幂</td>
</tr>
<tr>
<td><code>%</code></td>
<td>求模</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加等(plus-equal) 把原变量值增加一个常量并重新赋值给变量</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减等(minus-equal) 把原变量值减少一个常量并重新赋值给变量</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘等(times-equal) 把原变量值乘上一个常量并重新赋值给变量</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除等(slash-equal) 把原变量值除以一个常量并重新赋值给变量</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模等(mod-equal) 把原变量值除以一个常量整除（即取模）并重新赋余数的值给变量</td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bash在版本2.02引入了<span class="string">&quot;**&quot;</span>求幂操作符.</span></span><br><span class="line">let &quot;z=5**3&quot;</span><br><span class="line">echo &quot;z = $z&quot;   # z = 125</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">求模（它返回整数整除一个数后的余数）</span></span><br><span class="line">let &quot;y=5 % 3&quot;</span><br><span class="line">echo &quot;y = $y&quot;   # y = 2</span><br><span class="line"></span><br><span class="line">let &quot;var += 5&quot; # 会使变量var值加了5并把值赋给var.</span><br><span class="line">let &quot;var *= 4&quot; # 使变量var的值乘上4并把值赋给var.</span><br></pre></td></tr></table></figure>

<h2 id="双括号结构"><a href="#双括号结构" class="headerlink" title="双括号结构"></a>双括号结构</h2><p>用<code>((...))</code>结构来处理变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(( a = 23 ))  # 以C风格来设置一个值，在&quot;=&quot;两边可以有空格.</span><br><span class="line">echo &quot;a (initial value) = $a&quot;</span><br><span class="line"></span><br><span class="line">(( a++ ))     # C风格的计算后自增.</span><br><span class="line">echo &quot;a (after a++) = $a&quot;</span><br><span class="line"></span><br><span class="line">(( a-- ))     # C风格的计算后自减.</span><br><span class="line">echo &quot;a (after a--) = $a&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(( ++a ))     # C风格的计算前自增.</span><br><span class="line">echo &quot;a (after ++a) = $a&quot;</span><br><span class="line"></span><br><span class="line">(( --a ))     # C风格的计算前自减.</span><br><span class="line">echo &quot;a (after --a) = $a&quot;</span><br></pre></td></tr></table></figure>
<p>算术运算符必须用双括号(( ))括起来，以便Shell可以正确地解析表达式</p>
<h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>在 sh&#x2F;bash 里，<strong>如果 else 分支没有语句执行，就不要写这个 else</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==========if============</span><br><span class="line">if condition;then</span><br><span class="line">  command</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========if-else=========</span><br><span class="line">if condition;then</span><br><span class="line">  command</span><br><span class="line">else</span><br><span class="line">  command</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=====if-elif-else=======</span><br><span class="line">if condition;then</span><br><span class="line">  command</span><br><span class="line">elif condition;then</span><br><span class="line">  command</span><br><span class="line">else</span><br><span class="line">  command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h2><p>如果下面的条件成立返回真</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>文件存在</td>
</tr>
<tr>
<td>-f</td>
<td>文件是一个普通文件(不是一个目录或是一个设备文件)</td>
</tr>
<tr>
<td>-d</td>
<td>文件是一个目录</td>
</tr>
<tr>
<td>-b</td>
<td>文件是一个块设备(软盘，光驱，等等。)</td>
</tr>
<tr>
<td>-c</td>
<td>文件是一个字符设备(键盘，调制解调器，声卡，等等。)</td>
</tr>
<tr>
<td>-p</td>
<td>文件是一个管道</td>
</tr>
<tr>
<td>-h</td>
<td>文件是一个符号链接</td>
</tr>
<tr>
<td>-L</td>
<td>文件是一个符号链接</td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ ! -f &quot;/data/filename&quot; ];then</span><br><span class="line">   echo &quot;文件不存在&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件存在&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">或者:</span><br><span class="line">FILE=/etc/resolv.conf</span><br><span class="line">if test -f &quot;$FILE&quot;; then</span><br><span class="line">    echo &quot;$FILE exist&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-f FILE - 判断文件是否存在</span><br><span class="line">-b FILE - 如果文件存在并且是块特殊文件，则为True。</span><br><span class="line">-c FILE - 如果文件存在并且是特殊字符文件，则为True。</span><br><span class="line">-d FILE - 如果文件存在并且是目录，则为True。</span><br></pre></td></tr></table></figure>

<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>二元比较操作符比较两个变量或是数值。注意整数和字符串比较的分别。</p>
<h3 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h3><table>
<thead>
<tr>
<th>比较操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>-eq</code></td>
<td>等于</td>
<td><code>if [ &quot;$a&quot; -eq &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>不等于</td>
<td><code>if [ &quot;$a&quot; -ne &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>大于</td>
<td><code>if [ &quot;$a&quot; -gt &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>大于等于</td>
<td><code>if [ &quot;$a&quot; -ge &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>小于</td>
<td><code>if [ &quot;$a&quot; -lt &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-le</code></td>
<td>小于等于</td>
<td><code>if [ &quot;$a&quot; -le &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于(在双括号里使用)</td>
<td><code>((&quot;$a&quot; &lt; &quot;$b&quot;))</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于 (在双括号里使用)</td>
<td><code>((&quot;$a&quot; &lt;= &quot;$b&quot;))</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于 (在双括号里使用)</td>
<td><code>((&quot;$a&quot; &gt; &quot;$b&quot;))</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于(在双括号里使用)</td>
<td><code>((&quot;$a&quot; &gt;= &quot;$b&quot;))</code></td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">-eq:等于</span><br><span class="line">-ne:不等于</span><br><span class="line">-gt:大于</span><br><span class="line">-lt:小于</span><br><span class="line">-ge:大于等于</span><br><span class="line">-le:小于等于</span><br></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><table>
<thead>
<tr>
<th>比较操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>等于</td>
<td><code>if [ &quot;$a&quot; = &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于，它和&#x3D;是同义词。</td>
<td><code>if [ &quot;$a&quot; == &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不相等，操作符在[[ … ]]结构里使用模式匹配.</td>
<td><code>if [ &quot;$a&quot; != &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td>-z</td>
<td>字符串为”null”，即是指字符串长度为零。</td>
<td>-</td>
</tr>
<tr>
<td>-n</td>
<td>字符串不为”null”，即长度不为零。</td>
<td>-</td>
</tr>
</tbody></table>
<p>比如，判断变量是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过-n判断</span><br><span class="line">if [ -n &quot;$var&quot; ];then</span><br><span class="line">   echo &quot;var exist&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;var not exist&quot;</span><br><span class="line">fi</span><br><span class="line">其中 &quot;&quot; 必不可缺少</span><br></pre></td></tr></table></figure>
<p>此外，在 Shell 中，[[ ]] 是 Shell 的内置命令，用于检测某个条件是否成立。同时，它支持正则表达式，可以使用&#x3D;~来检测字符串是否符合某个正则表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [[ $APK == *release*.apk ]]; then</span><br><span class="line">    # 测试apk是否满足这样的格式</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="逻辑比较"><a href="#逻辑比较" class="headerlink" title="逻辑比较"></a>逻辑比较</h3><table>
<thead>
<tr>
<th>比较操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>逻辑与，如果exp1和exp2都为真，则exp1 -a exp2返回真。</td>
<td><code>if [ &quot;$exp1&quot; -a &quot;$exp2&quot; ]</code></td>
</tr>
<tr>
<td>-o</td>
<td>逻辑或，只要exp1和exp2任何一个为真，则exp1 -o exp2 返回真。</td>
<td><code>if [ &quot;$exp1&quot; -o &quot;$exp2&quot; ]</code></td>
</tr>
</tbody></table>
<p>也可以用这种方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1||command2</span><br><span class="line">只有当command1不正确执行才执行command2</span><br><span class="line">if [[ $suffix == *.apk ]] || [[ $suffix == *.zip ]]; then</span><br><span class="line">    # 后缀是apk或者zip</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [[ &quot;$local_branch&quot; = &quot;origin/release&quot;* ]] || [[ &quot;$local_branch&quot; = &quot;origin/internal&quot;* ]];then</span><br><span class="line">      </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="命令的静默输出"><a href="#命令的静默输出" class="headerlink" title="命令的静默输出"></a>命令的静默输出</h3><p>有些命令可以用来判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找某个分支是否存在，如果存在就删除</span><br><span class="line">if git show-ref --verify --quiet refs/heads/$2; then</span><br><span class="line">   git branch -D $2;</span><br><span class="line">fi</span><br><span class="line">  </span><br><span class="line">grep -q &quot;test&quot; filename</span><br><span class="line"># 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span><br><span class="line"></span><br><span class="line">if grep -q &#x27;test&#x27; filename;then</span><br><span class="line">  echo &quot;find test&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>判断上一条命令是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff a.txt b.txt   #diff文件有差别时，命令的返回结果不为0</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">   echo &quot;文件比较有差别&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto</span><br><span class="line">do</span><br><span class="line">  echo $planet  # 每个行星被单独打印在一行上.</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>以命令的返回结果作为list来进行循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIRS=$(ls -l|sed &#x27;1d&#x27;|awk &#x27;&#123;print $9&#125;&#x27;)</span><br><span class="line"># 此处要删除第一行，因为第一行是total </span><br><span class="line">for dir in $&#123;DIRS[*]&#125;</span><br><span class="line">do</span><br><span class="line">   echo $dir</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>数字循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#有一组urls,按照;分割后</span><br><span class="line">for url in $(echo &quot;$urls&quot; | awk -F&#x27;;&#x27; &#x27;&#123;for(i=1;i&lt;=NF;i++) print $i&#125;&#x27;); do</span><br><span class="line">  curl &quot;$url&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#使用seq命令生成数字序列</span><br><span class="line">for i in $(seq 1 5)</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">   statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">num=0</span><br><span class="line">while ((num &lt; 3))</span><br><span class="line">do</span><br><span class="line">	echo $num</span><br><span class="line">	((num++))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">var0=0</span><br><span class="line">LIMIT=10</span><br><span class="line"></span><br><span class="line">while [ &quot;$var0&quot; -lt &quot;$LIMIT&quot; ]</span><br><span class="line">do</span><br><span class="line">  echo -n &quot;$var0 &quot;        # -n 将会阻止产生新行。</span><br><span class="line">  #             ^           空格,数字之间的分隔。</span><br><span class="line">  var0=`expr $var0 + 1`   # var0=$(($var0+1))  也可以。</span><br><span class="line">                          # var0=$((var0 + 1)) 也可以。</span><br><span class="line">                          # let &quot;var0 += 1&quot;    也可以。</span><br><span class="line">done                      # 使用其他的方法也行。</span><br></pre></td></tr></table></figure>
<p>读文件的每一行直到末尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    # do something to each line</span><br><span class="line">done &lt; file</span><br></pre></td></tr></table></figure>

<h2 id="case-…-esac"><a href="#case-…-esac" class="headerlink" title="case … esac"></a>case … esac</h2><p>类似switch case</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case 变量 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>示例:  输入 1 到 4 之间的数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read Num</span><br><span class="line">case $Num in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title>linux文件管理</title>
    <url>/posts/3fd89380/</url>
    <content><![CDATA[<h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p>在linux系统中，可以说一切（包括目录、普通文件、设备文件等）皆为文件。文件类型包含有普通文件、目录、字符设备文件、块设备文件、符号链接文件、管道文件等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -ls时，第一列(如lrwxr-xr-x)的第一个字符(l)就是用来区分文件类型的。</span><br><span class="line"></span><br><span class="line">常见的种类有:</span><br><span class="line">1.  d 表示是目录</span><br><span class="line">2.  - 表示是文件</span><br><span class="line">3.  l 表示为链接文件</span><br><span class="line">4.  b 表示块设备和其他外围设备</span><br><span class="line">5.  c 字符设备文件</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>通过如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ls -l /etc/localtime</span><br><span class="line">lrwxr-xr-x  1 root  wheel  39  5 23 14:10 /etc/localtime -&gt; /var/db/timezone/zoneinfo/Asia/Shanghai</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到&#x2F;etc&#x2F;localtime指向&#x2F;var&#x2F;db&#x2F;timezone&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai</p>
<p>在linux系统中，链接可分为两种:一种为硬链接，另一种为软链接或符号链接。</p>
<h3 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">硬链接  ln 源文件 目标文件 </span><br><span class="line">软链接  ln -s 源文件 目标文件 （目标文件不能事先存在）</span><br></pre></td></tr></table></figure>

<ul>
<li>源文件：指定链接的源文件。如果使用<code>-s</code>选项创建软链接，则“源文件”可以是文件或者目录。创建硬链接时，则“源文件”参数只能是文件。</li>
<li>目标文件：指定源文件的目标链接文件。</li>
</ul>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>在目录<code>/usr/liu</code>下建立一个符号链接文件abc，使它指向目录<code>/usr/mengqc/mub1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/mengqc/mub1 /usr/liu/abc</span><br></pre></td></tr></table></figure>
<p>也就是读取&#x2F;usr&#x2F;liu&#x2F;abc时，实际访问的是&#x2F;usr&#x2F;mengqc&#x2F;mub1</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>给文件创建硬链接，为 <code>myfile</code> 创建硬链接 <code>hard</code>，<code>myfile</code> 与 <code>hard</code> 的文件 <code>inode</code> 值相同，它指向了物理硬盘的一个区块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch myfile &amp;&amp; echo &quot;This is a plain text file.&quot; &gt; myfile</span><br><span class="line">$ cat myfile</span><br><span class="line">This is a plain text file.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ln myfile hard</span><br><span class="line">$ ls -li</span><br><span class="line">25869085 -rw-r--r--  2 unixzii  staff  27  7  8 17:39 hard</span><br><span class="line">25869085 -rw-r--r--  2 unixzii  staff  27  7  8 17:39 myfile</span><br><span class="line">                   链接数为2</span><br></pre></td></tr></table></figure>

<p>在默认情况下，ln命令创建硬链接。ln命令会增加链接数，rm命令会减少链接数。一个文件除非链接数为0，否则不会从文件系统中被物理地删除。</p>
<h1 id="文件属组和文件权限"><a href="#文件属组和文件权限" class="headerlink" title="文件属组和文件权限"></a>文件属组和文件权限</h1><p>一个文件对于不同属组，不同所有者有不同的读写权限。</p>
<p>文件的基本权限包含如下：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>含义</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读</td>
<td>4</td>
</tr>
<tr>
<td>w</td>
<td>写</td>
<td>2</td>
</tr>
<tr>
<td>x</td>
<td>执行</td>
<td>1</td>
</tr>
<tr>
<td>-</td>
<td>无</td>
<td>0</td>
</tr>
</tbody></table>
<p>文件属性第一列(如:lrwxr-xr-x)的第二到第十个字符(rwxr-x-wx)定义了不同用户组对该文件的访问权限</p>
<table>
<thead>
<tr>
<th>2-4字符</th>
<th>5-7字符</th>
<th>8-10字符</th>
</tr>
</thead>
<tbody><tr>
<td>文件所有者权限</td>
<td>文件所属组</td>
<td>其他用户组</td>
</tr>
</tbody></table>
<h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><p>想要对文件操作必须有对应的权限。</p>
<p>修改权限可以使用全数字的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 740 file </span><br></pre></td></tr></table></figure>

<p>或者,使用对对应组用户赋予对应权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u g o a 分别是user,group,other,all的意思。</span><br><span class="line">+,-,=代表增加权限，删除权限，或者直接赋于权限</span><br><span class="line">chmod u=rwx,g=rx,o=r  test1</span><br><span class="line">chmod u+rx test2</span><br><span class="line">chmod a-x  test3</span><br></pre></td></tr></table></figure>

<h2 id="修改所属用户与组"><a href="#修改所属用户与组" class="headerlink" title="修改所属用户与组"></a>修改所属用户与组</h2><p>可以修改文件的所属组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>用wc命令来统计字符数</title>
    <url>/posts/270bc33d/</url>
    <content><![CDATA[<h1 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h1><p>统计文件的字节数、字数、行数</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>wc命令</strong> 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。</p>
<span id="more"></span>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc(选项)(参数)</span><br><span class="line">wc [选项]... [文件]...</span><br><span class="line">wc [选项]... --files0-from=F</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c # 统计字节数，或--bytes：显示Bytes数。</span><br><span class="line">-l # 统计行数，或--lines：显示列数。</span><br><span class="line">-m # 统计字符数，或--chars：显示字符数。</span><br><span class="line">-w # 统计字数，或--words：显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</span><br><span class="line">-L # 打印最长行的长度，或--max-line-length。</span><br><span class="line">-help     # 显示帮助信息。</span><br><span class="line">--version # 显示版本信息。</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>文件：需要统计的文件列表。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc -l *       # 统计当前目录下的所有文件行数及总计行数。</span><br><span class="line">wc -l *.js    # 统计当前目录下的所有 .js 后缀的文件行数及总计行数。</span><br><span class="line">find  . * | xargs wc -l # 当前目录以及子目录的所有文件行数及总计行数。</span><br></pre></td></tr></table></figure>

<p>查看文件的字节数、字数、行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">7     8     70     test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">行数 单词数 字节数 文件名</span></span><br></pre></td></tr></table></figure>

<p>用wc命令怎么做到只打印统计数字不打印文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc -l &lt; test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>用来统计当前目录下的文件数(不包含隐藏文件)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要去除TOTAL行</span></span><br><span class="line">expr $(ls -l | wc -l) - 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>统计当前目录下的所有文件行数及总计行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# wc -l *</span><br><span class="line">      21 LICENSE</span><br><span class="line">     270 README.md</span><br><span class="line">wc: example: read: Is a directory</span><br><span class="line">     785 lerna-debug.log</span><br><span class="line">      25 lerna.json</span><br><span class="line">wc: node_modules: read: Is a directory</span><br><span class="line">   23603 package-lock.json</span><br><span class="line">      79 package.json</span><br><span class="line">       3 renovate.json</span><br><span class="line">   24786 total</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>用cut命令来切割字符串</title>
    <url>/posts/9b60227b/</url>
    <content><![CDATA[<h1 id="Cut"><a href="#Cut" class="headerlink" title="Cut"></a>Cut</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut（选项）（参数）</span><br><span class="line"></span><br><span class="line">-b：仅显示行中指定直接范围的内容；</span><br><span class="line">-c：仅显示行中指定范围的字符；</span><br><span class="line">-d：指定字段的分隔符，默认的字段分隔符为“TAB”；</span><br><span class="line">-f：显示指定字段的内容；</span><br><span class="line">-n：与“-b”选项连用，不分割多字节字符；</span><br><span class="line">--complement：补足被选择的字节、字符或字段；</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>例如有一个学生报表信息，包含 No、Name、Mark、Percent：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test.txt</span><br><span class="line">No Name Mark Percent</span><br><span class="line">01 tom 69 91</span><br><span class="line">02 jack 71 87</span><br><span class="line">03 alex 68 98</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用  <strong>-f</strong>  选项提取指定字段（这里的 f 参数可以简单记忆为 <code>--fields</code>的缩写）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f 1 test.txt</span><br><span class="line">No</span><br><span class="line">01</span><br><span class="line">02</span><br><span class="line">03</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2,3 test.txt</span><br><span class="line">Name Mark</span><br><span class="line">tom 69</span><br><span class="line">jack 71</span><br><span class="line">alex 68</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>–complement</strong>  选项提取指定字段之外的列（打印除了第二列之外的列）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2 --complement test.txt</span><br><span class="line">No Mark Percent</span><br><span class="line">01 69 91</span><br><span class="line">02 71 87</span><br><span class="line">03 68 98</span><br></pre></td></tr></table></figure>

<p>使用  <strong>-d</strong>  选项指定字段分隔符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test2.txt</span><br><span class="line">No;Name;Mark;Percent</span><br><span class="line">01;tom;69;91</span><br><span class="line">02;jack;71;87</span><br><span class="line">03;alex;68;98</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2 -d&quot;;&quot; test2.txt</span><br><span class="line">Name</span><br><span class="line">tom</span><br><span class="line">jack</span><br><span class="line">alex</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指定字段的字符或者字节范围"><a href="#指定字段的字符或者字节范围" class="headerlink" title="指定字段的字符或者字节范围"></a>指定字段的字符或者字节范围</h3><p>cut 命令可以将一串字符作为列来显示，字符字段的记法：</p>
<ul>
<li><strong>N-</strong> ：从第 N 个字节、字符、字段到结尾；</li>
<li><strong>N-M</strong> ：从第 N 个字节、字符、字段到第 M 个（包括 M 在内）字节、字符、字段；</li>
<li><strong>-M</strong> ：从第 1 个字节、字符、字段到第 M 个（包括 M 在内）字节、字符、字段。</li>
</ul>
<p>上面是记法，结合下面选项将摸个范围的字节、字符指定为字段：</p>
<ul>
<li><strong>-b</strong>  表示字节；</li>
<li><strong>-c</strong>  表示字符；</li>
<li><strong>-f</strong>  表示定义字段。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test.txt</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印第 1 个到第 3 个字符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c1-3 test.txt</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印前 2 个字符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c-2 test.txt</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印从第 5 个字符开始到结尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c5- test.txt</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>

<p>打印最后5个字符: </p>
<p>遗憾的是, <code>cut</code>并没有提供最后字符的支持. 不过我们可以通过字符串反转来实现. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test.txt| rev | cut -c -5 | rev</span><br><span class="line">vwxyz</span><br><span class="line">vwxyz</span><br><span class="line">vwxyz</span><br><span class="line">vwxyz</span><br><span class="line">vwxyz</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>trap捕获信号</title>
    <url>/posts/50609df4/</url>
    <content><![CDATA[<h1 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h1><p>捕捉信号和其他事件并执行命令。</p>
<span id="more"></span>

<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trap [-lp] [[arg] signal_spec ...]</span><br></pre></td></tr></table></figure>

<h2 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h2><ul>
<li>用于指定在接收到信号后将要采取的动作。</li>
<li>脚本程序被中断时执行清理工作。</li>
</ul>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-l    打印信号名称以及信号名称对应的数字。</span><br><span class="line">-p    显示与每个信号关联的trap命令。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arg：接收到信号时执行的命令。</span><br><span class="line">signal_spec：信号名称或信号名称对应的数字。</span><br></pre></td></tr></table></figure>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>如果表达式执行结果为成功时返回0，当参数 <code>signal_spec</code> 没有指定有效值时返回1。</p>
<h2 id="关于信号"><a href="#关于信号" class="headerlink" title="关于信号"></a>关于信号</h2><p>信号是一种进程间通信机制，它给应用程序提供一种异步的软件中断，使应用程序有机会接受其他程序活终端发送的命令(即信号)。应用程序收到信号后，有三种处理方式：忽略，默认，或捕捉。进程收到一个信号后，会检查对该信号的处理机制。如果是SIG_IGN，就忽略该信号；如果是SIG_DFT，则会采用系统默认的处理动作，通常是终止进程或忽略该信号；如果给该信号指定了一个处理函数(捕捉)，则会中断当前进程正在执行的任务，转而去执行该信号的处理函数，返回后再继续执行被中断的任务。</p>
<p>在有些情况下，我们不希望自己的shell脚本在运行时刻被中断，比如说我们写得shell脚本设为某一用户的默认shell，使这一用户进入系统后只能作某一项工作，如数据库备份， 我们可不希望用户使用 Ctrl+C 等方法进入到shell状态做我们不希望做的事情。这便用到了信号处理。</p>
<p>以下是一些你可能会遇到的常见信号：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>信号数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIGHUP</td>
<td>1</td>
<td>本信号在用户终端连接（正常或非正常）结束时发出，通常是在终端的控制进程结束时，通知同一session内的各个作业，这时它们与控制终端不再关联。登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>程序终止(interrupt)信号，在用户键入 Ctrl+C 时发出。</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>和SIGINT类似，但由QUIT字符(通常是Ctrl+\)来控制。进程在因收到SIGQUIT退出时会产生core文件，在这个意义上类似于一个程序错误信号。</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术错误。</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>用来立即结束程序的运行。本信号不能被阻塞，处理和忽略。</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号。</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理. 通常用来要求程序自己正常退出；kill 命令缺省产生这个信号。</td>
</tr>
</tbody></table>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>当shell收到 <code>HUP INT PIPE QUIT TERM</code> 这几个命令时，当前执行的程序会执行 <code>exit 1</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@pc root]$ trap &quot;exit 1&quot; HUP INT PIPE QUIT TERM</span><br></pre></td></tr></table></figure>

<h3 id="1-清理临时文件"><a href="#1-清理临时文件" class="headerlink" title="1 清理临时文件"></a>1 清理临时文件</h3><p>下面展示了如果有人试图从终端中止程序时，如何删除文件然后退出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trap &quot;rm -f $WORKDIR/work1 $WORKDIR/dataout; exit&quot; 2</span><br></pre></td></tr></table></figure>

<p>执行shell程序，如果程序接收信号为2，那么这两个文件 （work1 和 dataout） 将被自动删除。</p>
<p>添加信号1 <code>SIGHUP</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> <span class="string">&quot;rm -f <span class="variable">$WORKDIR</span>/work1 <span class="variable">$WORKDIR</span>/dataout; exit&quot;</span> 1 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-忽略信号"><a href="#2-忽略信号" class="headerlink" title="2 忽略信号"></a>2 忽略信号</h3><p>如果陷阱列出的命令是空的，指定的信号接收时，将被忽略：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> <span class="string">&#x27;&#x27;</span> 2</span></span><br></pre></td></tr></table></figure>

<p>忽略多个信号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> <span class="string">&#x27;&#x27;</span> 1 2 3 15</span></span><br></pre></td></tr></table></figure>


<h3 id="3-重置陷阱"><a href="#3-重置陷阱" class="headerlink" title="3 重置陷阱"></a>3 重置陷阱</h3><p>当你改变了收到信号后采取的动作，你可以省略第一个参数来重置到默认行为。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> 1 2</span></span><br></pre></td></tr></table></figure>


<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li><code>trap -l</code> 等价于执行 <code>kill -l</code>。</li>
<li>发送信号请查看 <code>kill</code> 命令。</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>用tee命令重定向标准输出</title>
    <url>/posts/aee075e4/</url>
    <content><![CDATA[<h1 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h1><p>从标准输入读取数据并重定向到标准输出和文件。主要用于，需要同时查看数据内容并输出到文件时使用。</p>
<span id="more"></span>

<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tee [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">FILE（可选）：要输出的文件，可以为一或多个。</span><br></pre></td></tr></table></figure>


<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">长选项与短选项等价</span><br><span class="line"></span><br><span class="line">-a, --append               追加到文件中而不是覆盖。</span><br><span class="line">-i, --ignore-interrupts    忽略中断信号（Ctrl+c中断操作无效）。</span><br><span class="line">-p                         诊断写入非管道的错误。</span><br><span class="line">--output-error[=MODE]      设置写错误时的行为，请查看下方的MODE部分。</span><br><span class="line">--help                     显示帮助信息并退出。</span><br><span class="line">--version                  显示版本信息并退出。</span><br><span class="line"></span><br><span class="line">MODE决定了当出现写错误时的输出行为，可用的MODE如下：</span><br><span class="line"></span><br><span class="line">&#x27;warn&#x27;           当写入到任何输出报错时诊断。</span><br><span class="line">&#x27;warn-nopipe&#x27;    当写入到任何输出（而不是管道）报错时诊断。</span><br><span class="line">&#x27;exit&#x27;           当写入到任何输出报错时退出。</span><br><span class="line">&#x27;exit-nopipe&#x27;    当写入到任何输出（而不是管道）报错时退出。</span><br><span class="line"></span><br><span class="line">-p选项的指定的默认MODE为&#x27;warn-nopipe&#x27;。</span><br><span class="line">当&#x27;--output-error&#x27;没有在选项中时，默认的操作是当写入到管道报错时立刻退出，诊断错误信息并写入到非管道输出。</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回状态为成功除非给出了非法选项或非法参数。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将进程信息通过管道输出到标准输出（终端）并覆盖写入到文件中。</span></span><br><span class="line">ps -ef |tee info_a.log info_b.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将进程信息通过管道输出到标准输出（终端）并追加写入到文件中。</span></span><br><span class="line">ps -ef |tee -a info_a.log info_b.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>type显示指定命令的类型</title>
    <url>/posts/784c8df/</url>
    <content><![CDATA[<h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><h2 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h2><ul>
<li>显示要查找的命令的信息。</li>
<li>控制查找范围和行为。</li>
<li>显示要查找的命令优先级最高的类型。</li>
</ul>
<span id="more"></span>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type [-afptP] name [name ...]</span><br><span class="line"></span><br><span class="line">name：要查找的命令，可以为多个。</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a：在环境变量PATH中查找并显示所有包含name的可执行文件路径；当&#x27;-p&#x27;选项没有同时给出时，如果在别名、关键字，函数，内建的信息中存在name，则一并显示。</span><br><span class="line">-f：排除对shell函数的查找。</span><br><span class="line">-p：如果name在执行&#x27;type -t name&#x27;返回的不是&#x27;file&#x27;，那么什么也不返回；否则会在环境变量PATH中查找并返回可执行文件路径。</span><br><span class="line">-P：即使要查找的name是别名、内建、函数中的一个，仍然会在环境变量PATH中查找并返回可执行文件路径。</span><br><span class="line">-t：根据name的类型返回一个单词（别名，关键字，函数，内建，文件），否则返回空值。</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>当指定的命令可以找到时返回成功，如果有没找到的返回失败。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>接下来要用到的例子假设’~&#x2F;.bashrc’文件定义了以下的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">mybash()&#123; vim ~/.bashrc; &#125;</span><br></pre></td></tr></table></figure>
<p>而且执行环境里没有使用enable禁用内建命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">mybash is a function</span><br><span class="line">mybash ()</span><br><span class="line">&#123;</span><br><span class="line">    vim ~/.bashrc</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a -f mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出（因为排除了函数，所以报错）</span></span><br><span class="line">bash: type: mybash: not found</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a -p mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出为空（因为排除了函数，所以什么也不返回）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">ls is aliased to `ls --color=suto&#x27;</span><br><span class="line">ls is /usr/bin/ls</span><br><span class="line">ls is /bin/ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a -p <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">/usr/bin/ls</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;-f&#x27;</span>不会影响<span class="string">&#x27;-P&#x27;</span>的范围，<span class="string">&#x27;-f&#x27;</span>不建议和<span class="string">&#x27;-p&#x27;</span>使用。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：<span class="built_in">printf</span>同时是内建命令以及可执行文件（GNU coreutils），优先作为内建处理。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -p <span class="built_in">printf</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出为空</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -P <span class="built_in">printf</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">/usr/bin/printf</span><br><span class="line">/bin/printf</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有多个类型，那么输出优先级最高的类型。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">alias</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t <span class="keyword">for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出（bash关键字）</span></span><br><span class="line">keyword</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">function</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t -f mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出空值</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t <span class="built_in">printf</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出（bash内建优先级高）</span></span><br><span class="line">builtin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t <span class="built_in">chmod</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">file</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>该命令是bash内建命令，相关的帮助信息请查看<code>help</code>命令。</li>
<li>命令优先级问题请查看<code>builtin</code>命令。</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>find查找文件</title>
    <url>/posts/89021aa2/</url>
    <content><![CDATA[<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<span id="more"></span>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find(选项)(参数)</span><br><span class="line"></span><br><span class="line">比较常用的参数:</span><br><span class="line">-prune：不寻找字符串作为寻找文件或目录的范本样式;</span><br><span class="line">-maxdepth&lt;目录层级&gt;：设置最大目录层级；</span><br><span class="line">-mindepth&lt;目录层级&gt;：设置最小目录层级；</span><br><span class="line">-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；</span><br><span class="line">-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</span><br><span class="line">-size&lt;文件大小&gt;：查找符合指定的文件大小的文件；</span><br><span class="line">-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式</span><br><span class="line">-depth：从指定目录下最深层的子目录开始查找；</span><br><span class="line">-empty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；</span><br><span class="line">-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基于名字查找-name"><a href="#基于名字查找-name" class="headerlink" title="基于名字查找-name"></a>基于名字查找-name</h3><p>在<code>/home</code>目录下查找以.txt结尾的文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<p>在当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br></pre></td></tr></table></figure>

<h3 id="基于路径查找-path"><a href="#基于路径查找-path" class="headerlink" title="基于路径查找-path"></a>基于路径查找-path</h3><p>匹配文件路径或者文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure>
<p>查找路径下所有example&#x2F;pubspec.yaml的文件,可以看到-path是支持Ant风格路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -path &quot;**/example/pubspec.yaml&quot;</span><br></pre></td></tr></table></figure>
<h3 id="否定参数"><a href="#否定参数" class="headerlink" title="否定参数"></a>否定参数</h3><p>找出&#x2F;home下不是以.txt结尾的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<h3 id="基于正则表达式匹配文件路径"><a href="#基于正则表达式匹配文件路径" class="headerlink" title="基于正则表达式匹配文件路径"></a>基于正则表达式匹配文件路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>

<p>同上，但忽略大小写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>

<h3 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h3><p>向下最大深度限制为3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -maxdepth 3 -type f</span><br></pre></td></tr></table></figure>

<p>搜索出深度距离当前目录至少2个子目录的所有文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -mindepth 2 -type f</span><br></pre></td></tr></table></figure>

<h3 id="根据文件大小进行匹配"><a href="#根据文件大小进行匹配" class="headerlink" title="根据文件大小进行匹配"></a>根据文件大小进行匹配</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size 文件大小单元</span><br></pre></td></tr></table></figure>

<p>文件大小单元：</p>
<ul>
<li><strong>b</strong>  —— 块（512字节）</li>
<li><strong>c</strong>  —— 字节</li>
<li><strong>w</strong>  —— 字（2字节）</li>
<li><strong>k</strong>  —— 千字节</li>
<li><strong>M</strong>  —— 兆字节</li>
<li><strong>G</strong>  —— 吉字节</li>
</ul>
<p>搜索大于10KB的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size +10k</span><br></pre></td></tr></table></figure>

<p>搜索小于10KB的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size -10k</span><br></pre></td></tr></table></figure>

<p>搜索等于10KB的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size 10k</span><br></pre></td></tr></table></figure>

<h3 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h3><p>删除当前目录下所有.txt文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -delete</span><br></pre></td></tr></table></figure>

<h3 id="借助-exec选项与其他命令结合使用"><a href="#借助-exec选项与其他命令结合使用" class="headerlink" title="借助-exec选项与其他命令结合使用"></a>借助<code>-exec</code>选项与其他命令结合使用</h3><p>找出当前目录下所有root的文件，并把所有权更改为用户tom</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -user root -exec chown tom &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上例中， <strong>{}</strong>  用于与 <strong>-exec</strong> 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</p>
<p>找出自己家目录下所有的.txt文件并删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find $HOME/. -name &quot;*.txt&quot; -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上例中， <strong>-ok</strong> 和 <strong>-exec</strong> 行为一样，不过它会给出提示，是否执行相应的操作。</p>
<p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; /all.txt</span><br></pre></td></tr></table></figure>

<p>将30天前的.log文件移动到old目录中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br></pre></td></tr></table></figure>

<p>找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-exec ./text.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="搜索但跳过指定的目录"><a href="#搜索但跳过指定的目录" class="headerlink" title="搜索但跳过指定的目录"></a>搜索但跳过指定的目录</h3><p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>

<blockquote>
<p>:warning: .&#x2F;sk 不能写成 .&#x2F;sk&#x2F; ，否则没有作用。</p>
</blockquote>
<p>忽略两个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . \( -path ./sk -o  -path ./st \) -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>

<blockquote>
<p>:warning: 如果写相对路径必须加上<code>./</code></p>
</blockquote>
<h3 id="find其他技巧收集"><a href="#find其他技巧收集" class="headerlink" title="find其他技巧收集"></a>find其他技巧收集</h3><p>要列出所有长度为零的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -empty</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/posts/2f57a694/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>正则表达式分为两类</p>
<ul>
<li>基本正则表达式 BRE</li>
<li>扩展正则表达式 ERE</li>
</ul>
<span id="more"></span>
<h2 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^         用于模式最左侧，如&quot;^boy&quot;,匹配以boy单词开头的行</span><br><span class="line">$         用于模式最左侧，如&quot;boy$&quot;,匹配以boy单词结尾的行</span><br><span class="line">^$        匹配空行</span><br><span class="line">\         转义，让特殊含义的字符显示原意</span><br><span class="line">*         匹配前一个字符连续出现0或1次以上</span><br><span class="line">.*        匹配所有内容</span><br><span class="line">^.*       匹配任意多个字符开头的内容</span><br><span class="line">.*$       匹配任意多个字符结尾的内容</span><br><span class="line">[abc]     匹配[]的任意一个字符，a或b或c</span><br><span class="line">[^abc]    与上面相反，非a非b非c的任意字符</span><br><span class="line">\&lt;        如:&#x27;\&lt;grep&#x27;匹配包含以grep开头的单词的行</span><br><span class="line">\&gt;        如:&#x27;grep\&gt;&#x27;匹配包含以grep结尾的单词的行</span><br></pre></td></tr></table></figure>

<h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+         匹配前一个字符 1次或多次</span><br><span class="line">[]+       匹配括号内的字符 1次或多次</span><br><span class="line">?         匹配前一个字符 0次或1次 </span><br><span class="line">|         同时过滤多个字符串</span><br><span class="line">()        被括起来的作为整体</span><br><span class="line">a&#123;n,m&#125;    匹配前一字符，最少n次，最多m次</span><br><span class="line">a&#123;n,&#125;     匹配前一字符，最少n次</span><br><span class="line">a&#123;n&#125;      匹配前一字符正好n次</span><br><span class="line">a&#123;,m&#125;     匹配前一字符，最多m次</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>三剑客grep,sed和awk</title>
    <url>/posts/e2f332a0/</url>
    <content><![CDATA[<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤&#x2F;搜索的特定字符</p>
<span id="more"></span>
<h2 id="grep命令常见用法"><a href="#grep命令常见用法" class="headerlink" title="grep命令常见用法"></a>grep命令常见用法</h2><p>在文件中搜索一个单词，命令会返回一个包含 <strong>“match_pattern”</strong> 的文本行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep match_pattern file_name</span><br><span class="line">grep &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c --count    # 计算符合范本样式的列数。</span><br><span class="line">-A &lt;显示行数&gt;   --after-context=&lt;显示行数&gt; # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span><br><span class="line">-B&lt;显示行数&gt;   --before-context=&lt;显示行数&gt;   # 除了显示符合样式的那一行之外，并显示该行之前的内容。</span><br><span class="line">-C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span><br><span class="line">-q --quiet或--silent     # 不显示任何信息。</span><br><span class="line">-v --revert-match # 反转查找。</span><br><span class="line">-o # 只输出文件中匹配到的部分。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在多个文件中查找：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;match_pattern&quot; file_1 file_2 file_3 ...</span><br></pre></td></tr></table></figure>

<p>输出除之外的所有行  <strong>-v</strong>  选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -v &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure>

<p>只输出文件中匹配到的部分  <strong>-o</strong>  选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is a test line. | grep -o -E &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line">echo this is a test line. | egrep -o &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br></pre></td></tr></table></figure>

<p>统计文件或者文本中包含匹配字符串的行数  <strong>-c</strong>  选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -c &quot;text&quot; file_name</span><br></pre></td></tr></table></figure>

<p>输出包含匹配字符串的行数  <strong>-n</strong>  选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;text&quot; -n file_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">cat file_name | grep &quot;text&quot; -n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多个文件</span></span><br><span class="line">grep &quot;text&quot; -n file_1 file_2</span><br></pre></td></tr></table></figure>

<p>在多级目录中对文本进行递归搜索：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;text&quot; . -r -n</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.表示当前目录。</span></span><br></pre></td></tr></table></figure>

<p>选项  <strong>-e</strong>  制动多个匹配样式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -o</span><br><span class="line">is</span><br><span class="line">is</span><br><span class="line">line</span><br></pre></td></tr></table></figure>

<p>在grep搜索结果中包括或者排除指定文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只在目录中所有的.php和.html文件中递归搜索字符<span class="string">&quot;main()&quot;</span></span></span><br><span class="line">grep &quot;main()&quot; . -r --include *.&#123;php,html&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在搜索结果中排除所有README文件</span></span><br><span class="line">grep &quot;main()&quot; . -r --exclude &quot;README&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在搜索结果中排除filelist文件列表里的文件</span></span><br><span class="line">grep &quot;main()&quot; . -r --exclude-from filelist</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>grep静默输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -q &quot;test&quot; filename</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span></span><br><span class="line"></span><br><span class="line">if grep -q &#x27;test&#x27; filename;then</span><br><span class="line">  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>打印出匹配文本之前或者之后的行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示匹配某个结果之后的3行，使用 -A 选项：</span></span><br><span class="line">seq 10 | grep &quot;5&quot; -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示匹配某个结果之前的3行，使用 -B 选项：</span></span><br><span class="line">seq 10 | grep &quot;5&quot; -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示匹配某个结果的前三行和后三行，使用 -C 选项：</span></span><br><span class="line">seq 10 | grep &quot;5&quot; -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：</span></span><br><span class="line">echo -e &quot;a\nb\nc\na\nb\nc&quot; | grep a -A 1</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p><strong>sed</strong> 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<p> <strong>命令格式</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed [options] &#x27;command&#x27; file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure>
<h2 id="sed用法实例"><a href="#sed用法实例" class="headerlink" title="sed用法实例"></a>sed用法实例</h2><h3 id="打印奇数行或偶数行"><a href="#打印奇数行或偶数行" class="headerlink" title="打印奇数行或偶数行"></a>打印奇数行或偶数行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;1~2p&#x27; test.txt  #奇数行</span><br><span class="line">sed -n &#x27;2~2p&#x27; test.txt  #偶数行</span><br></pre></td></tr></table></figure>

<h3 id="替换操作：s命令"><a href="#替换操作：s命令" class="headerlink" title="替换操作：s命令"></a>替换操作：s命令</h3><p>替换文本中的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/book/books/&#x27; file</span><br></pre></td></tr></table></figure>

<p> <strong>-n选项</strong> 和 <strong>p命令</strong> 一起使用表示只打印那些发生替换的行：</p>
<p>sed -n ‘s&#x2F;test&#x2F;TEST&#x2F;p’ file</p>
<p>直接编辑文件 <strong>选项-i</strong> ，会匹配file文件中每一行的所有book替换为books：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/book/books/g&#x27; file</span><br></pre></td></tr></table></figure>

<h3 id="全面替换标记g"><a href="#全面替换标记g" class="headerlink" title="全面替换标记g"></a>全面替换标记g</h3><p>使用后缀 &#x2F;g 标记会替换每一行中的所有匹配：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/book/books/g&#x27; file</span><br></pre></td></tr></table></figure>

<p>当需要从第N处匹配开始替换时，可以使用 &#x2F;Ng：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/2g&#x27;</span><br><span class="line">skSKSKSKSKSK</span><br><span class="line"></span><br><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/3g&#x27;</span><br><span class="line">skskSKSKSKSK</span><br><span class="line"></span><br><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/4g&#x27;</span><br><span class="line">skskskSKSKSK</span><br></pre></td></tr></table></figure>

<h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h3><p>以上命令中字符 &#x2F; 在sed中作为定界符使用，也可以使用任意的定界符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s:test:TEXT:g&#x27;</span><br><span class="line">sed &#x27;s|test|TEXT|g&#x27;</span><br></pre></td></tr></table></figure>

<p>定界符出现在样式内部时，需要进行转义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/\/bin/\/usr\/local\/bin/g&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="删除操作：d命令"><a href="#删除操作：d命令" class="headerlink" title="删除操作：d命令"></a>删除操作：d命令</h3><p>删除空白行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^$/d&#x27; file</span><br></pre></td></tr></table></figure>
<p>删除文件的第2行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;2d&#x27; file</span><br><span class="line">sed &#x27;2d;5d&#x27; file</span><br></pre></td></tr></table></figure>
<p>删除文件的第2行到末尾所有行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;2,$d&#x27; file</span><br></pre></td></tr></table></figure>
<p>删除文件最后一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;$d&#x27; file</span><br></pre></td></tr></table></figure>
<p>删除文件中所有开头是test的行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^test/&#x27;d file</span><br></pre></td></tr></table></figure>
<h3 id="已匹配字符串标记"><a href="#已匹配字符串标记" class="headerlink" title="已匹配字符串标记&amp;"></a>已匹配字符串标记&amp;</h3><p>正则表达式 \w+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is a test line | sed &#x27;s/\w\+/[&amp;]/g&#x27;</span><br><span class="line">[this] [is] [a] [test] [line]</span><br></pre></td></tr></table></figure>

<p>所有以192.168.0.1开头的行都会被替换成它自已加localhost：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/^192.168.0.1/&amp;localhost/&#x27; file</span><br><span class="line">192.168.0.1localhost</span><br></pre></td></tr></table></figure>

<h3 id="子串匹配标记-1"><a href="#子串匹配标记-1" class="headerlink" title="子串匹配标记\1"></a>子串匹配标记\1</h3><p>匹配给定样式的其中一部分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is digit 7 in a number | sed &#x27;s/digit \([0-9]\)/\1/&#x27;</span><br><span class="line">this is 7 in a number</span><br></pre></td></tr></table></figure>

<p>命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，(..) 用于匹配子串，对于匹配到的第一个子串就标记为  <strong>\1</strong> ，依此类推匹配到的第二个结果就是  <strong>\2</strong> ，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo aaa BBB | sed &#x27;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#x27;</span><br><span class="line">BBB aaa</span><br></pre></td></tr></table></figure>

<p>love被标记为1，所有loveable会被替换成lovers，并打印出来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;s/\(love\)able/\1rs/p&#x27; file</span><br></pre></td></tr></table></figure>

<p>通过替换获取ip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig ens32 | sed -n &#x27;/inet /p&#x27; | sed &#x27;s/inet \([0-9.]\+\).*/\1/&#x27;</span><br><span class="line">192.168.75.126</span><br></pre></td></tr></table></figure>
<h3 id="大小写转换U-L"><a href="#大小写转换U-L" class="headerlink" title="大小写转换U&#x2F;L"></a>大小写转换U&#x2F;L</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\u：	首字母转换为大写</span><br><span class="line">\U：  全部转换为大写</span><br><span class="line">\l：	 首字母转换为小写</span><br><span class="line">\L：	 全部转换为小写</span><br></pre></td></tr></table></figure>

<p>首字母转换为大写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]# sed &#x27;s/^[a-z]\+/\u&amp;/&#x27; passwd </span><br><span class="line">Root:x:0:0:root:/root:/bin/bash</span><br><span class="line">Bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">Daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">Adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">Lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">Sync:x:5:0:sync:/sbin:/bin/sync</span><br></pre></td></tr></table></figure>

<p>匹配到的字符全部转换为大写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]# sed &#x27;s/^[a-z]\+/\U&amp;/&#x27; passwd </span><br><span class="line">ROOT:x:0:0:root:/root:/bin/bash</span><br><span class="line">BIN:x:1:1:bin:/bin:/sbin/nologin</span><br></pre></td></tr></table></figure>

<h3 id="组合多个表达式"><a href="#组合多个表达式" class="headerlink" title="组合多个表达式"></a>组合多个表达式</h3><ol>
<li>替换文本中的多个字符串：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;s/old_string/new_string/g&#x27; -e &#x27;s/another_old_string/another_new_string/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除文本中的多个行：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;1d&#x27; -e &#x27;/pattern/d&#x27; file.txt</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在文本中插入多个行：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;1i\inserted_line1&#x27; -e &#x27;2i\inserted_line2&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>其中，-e 表示指定一个表达式，多个表达式之间用 -e 分隔。每个表达式可以是一个 sed 命令，例如 s、d、i 等。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test=hello</span><br><span class="line">echo hello WORLD | sed &quot;s/$test/HELLO&quot;</span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h3 id="选定行的范围：-（逗号）"><a href="#选定行的范围：-（逗号）" class="headerlink" title="选定行的范围：,（逗号）"></a>选定行的范围：,（逗号）</h3><p>所有在模板test和check所确定的范围内的行都被打印：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/test/,/check/p&#x27; file</span><br></pre></td></tr></table></figure>

<p>打印从第5行开始到第一个包含以test开始的行之间的所有行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;5,/^test/p&#x27; file</span><br></pre></td></tr></table></figure>

<p>对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/test/,/west/s/$/aaa bbb/&#x27; file</span><br></pre></td></tr></table></figure>

<h3 id="多点编辑：e命令"><a href="#多点编辑：e命令" class="headerlink" title="多点编辑：e命令"></a>多点编辑：e命令</h3><p>-e选项允许在同一行里执行多条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;1,5d&#x27; -e &#x27;s/test/check/&#x27; file</span><br><span class="line"></span><br><span class="line">echo &quot;hello, world &quot; | cut -d&#x27;,&#x27; -f2 | sed -e &#x27;s/^[[:space:]]*//&#x27; -e &#x27;s/[[:space:]]*$//&#x27;</span><br><span class="line">去除单词前面跟后面的空格</span><br><span class="line"></span><br><span class="line">echo &quot; key = value &quot;|cut -d &#x27;=&#x27; -f 2|sed -e &#x27;s/^[[:space:]]*//&#x27; -e &#x27;s/[[:space:]]*$//&#x27;</span><br></pre></td></tr></table></figure>

<p>上面sed表达式的第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</p>
<h3 id="追加（行下）：a-命令"><a href="#追加（行下）：a-命令" class="headerlink" title="追加（行下）：a\命令"></a>追加（行下）：a\命令</h3><p>将 this is a test line 追加到 以test 开头的行后面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^test/a\this is a test line&#x27; file</span><br></pre></td></tr></table></figure>

<p>在 test.conf 文件第2行之后插入 this is a test line：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;2a\this is a test line&#x27; test.conf</span><br></pre></td></tr></table></figure>

<h3 id="插入（行上）：i-命令"><a href="#插入（行上）：i-命令" class="headerlink" title="插入（行上）：i\命令"></a>插入（行上）：i\命令</h3><p>将 this is a test line 追加到以test开头的行前面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^test/i\this is a test line&#x27; file</span><br></pre></td></tr></table></figure>

<p>在test.conf文件第5行之前插入this is a test line：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;5i\this is a test line&#x27; test.conf</span><br></pre></td></tr></table></figure>

<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p><strong>awk</strong> 是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p>
<h2 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h2><p><strong>语法形式</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk [options] &#x27;script&#x27; var=value file(s)</span><br><span class="line">awk [options] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure>

<p><strong>常用命令选项</strong> </p>
<ul>
<li><strong>-F fs</strong> fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:，默认的分隔符是连续的空格或制表符</li>
<li><strong>-v var&#x3D;value</strong> 赋值一个用户定义变量，将外部变量传递给awk</li>
<li><strong>-f scripfile</strong> 从脚本文件中读取awk命令</li>
</ul>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式可以是以下任意一个：</p>
<ul>
<li>&#x2F;正则表达式&#x2F;：使用通配符的扩展集。</li>
<li>关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。</li>
<li>模式匹配表达式：用运算符<code>~</code>（匹配）和<code>!~</code>（不匹配）。</li>
<li>BEGIN语句块、pattern语句块、END语句块：参见awk的工作原理</li>
</ul>
<h2 id="awk脚本基本结构"><a href="#awk脚本基本结构" class="headerlink" title="awk脚本基本结构"></a>awk脚本基本结构</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; print &quot;start&quot; &#125; pattern&#123; commands &#125; END&#123; print &quot;end&quot; &#125;&#x27; file</span><br></pre></td></tr></table></figure>

<p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被 <strong>单引号</strong> 中，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;&#x27; filename</span><br></pre></td></tr></table></figure>

<h3 id="awk的工作原理"><a href="#awk的工作原理" class="headerlink" title="awk的工作原理"></a>awk的工作原理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：执行<code>BEGIN&#123; commands &#125;</code>语句块中的语句；</li>
<li>第二步：从文件或标准输入(stdin)读取一行，然后执行<code>pattern&#123; commands &#125;</code>语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。</li>
<li>第三步：当读至输入流末尾时，执行<code>END&#123; commands &#125;</code>语句块。</li>
</ul>
<p> <strong>BEGIN语句块</strong> 在awk开始从输入流中读取行 <strong>之前</strong> 被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p>
<p> <strong>END语句块</strong> 在awk从输入流中读取完所有的行 <strong>之后</strong> 即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p>
<p> <strong>pattern语句块</strong> 中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行<code>&#123; print &#125;</code>，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p>
<p> <strong>示例</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;A line 1\nA line 2&quot; | awk &#x27;BEGIN&#123; print &quot;Start&quot; &#125; &#123; print &#125; END&#123; print &quot;End&quot; &#125;&#x27;</span><br><span class="line">Start</span><br><span class="line">A line 1</span><br><span class="line">A line 2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>当使用不带参数的<code>print</code>时，它就打印当前行，当<code>print</code>的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo | awk &#x27;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; &#125;&#x27; </span><br><span class="line">v1 v2 v3</span><br></pre></td></tr></table></figure>

<p>双引号拼接使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo | awk &#x27;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; &#125;&#x27;</span><br><span class="line">v1=v2=v3</span><br></pre></td></tr></table></figure>

<p>{ }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i&#x3D;0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。</p>
<h2 id="awk内置变量（预定义变量）"><a href="#awk内置变量（预定义变量）" class="headerlink" title="awk内置变量（预定义变量）"></a>awk内置变量（预定义变量）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">**$n**  当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 </span><br><span class="line">**$0**  这个变量包含执行过程中当前行的文本内容。</span><br><span class="line"></span><br><span class="line">**FILENAME**  当前输入文件的名。</span><br><span class="line">**FS**  字段分隔符（默认是任何空格）。</span><br><span class="line">**NF**  表示字段数，在执行过程中对应于当前的字段数。</span><br><span class="line">**NR**  表示记录数，在执行过程中对应于当前的行号。</span><br><span class="line">**OFMT**  数字的输出格式（默认值是%.6g）。</span><br><span class="line">**OFS**  输出字段分隔符（默认值是一个空格）。</span><br><span class="line">**ORS**  输出记录分隔符（默认值是一个换行符）。</span><br><span class="line">**RS**  记录分隔符（默认是一个换行符）。</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3\nline2 f4 f5\nline3 f6 f7&quot; | awk &#x27;&#123;print &quot;Line No:&quot;NR&quot;, No of fields:&quot;NF, &quot;$0=&quot;$0, &quot;$1=&quot;$1, &quot;$2=&quot;$2, &quot;$3=&quot;$3&#125;&#x27; </span><br><span class="line">Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3</span><br><span class="line">Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5</span><br><span class="line">Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7</span><br></pre></td></tr></table></figure>

<p>使用<code>print $NF</code>可以打印出一行中的最后一个字段，使用<code>$(NF-1)</code>则是打印倒数第二个字段，其他以此类推：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3\n line2 f4 f5&quot; | awk &#x27;&#123;print $NF&#125;&#x27;</span><br><span class="line">f3</span><br><span class="line">f5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3\n line2 f4 f5&quot; | awk &#x27;&#123;print $(NF-1)&#125;&#x27;</span><br><span class="line">f2</span><br><span class="line">f4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印每一行的第二和第三个字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123; print $2,$3 &#125;&#x27; filename</span><br></pre></td></tr></table></figure>

<p>统计文件中的行数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;END&#123; print NR &#125;&#x27; filename</span><br></pre></td></tr></table></figure>

<p>以上命令只使用了END语句块，在读入每一行的时，awk会将NR更新为对应的行号，当到达最后一行NR的值就是最后一行的行号，所以END语句块中的NR就是文件的行数。</p>
<p>一个每一行中第一个字段值累加的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seq 5 | awk &#x27;BEGIN&#123; sum=0; print &quot;总和：&quot; &#125; &#123; print $1&quot;+&quot;; sum+=$1 &#125; END&#123; print &quot;等于&quot;; print sum &#125;&#x27; </span><br><span class="line">总和：</span><br><span class="line">1+</span><br><span class="line">2+</span><br><span class="line">3+</span><br><span class="line">4+</span><br><span class="line">5+</span><br><span class="line">等于</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<h2 id="将外部变量值传递给awk"><a href="#将外部变量值传递给awk" class="headerlink" title="将外部变量值传递给awk"></a>将外部变量值传递给awk</h2><p>借助 <strong><code>-v</code>选项</strong> ，可以将外部值（并非来自stdin）传递给awk：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VAR=10000</span><br><span class="line">echo | awk -v VARIABLE=$VAR &#x27;&#123; print VARIABLE &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>另一种传递外部变量方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var1=&quot;aaa&quot;</span><br><span class="line">var2=&quot;bbb&quot;</span><br><span class="line">echo | awk &#x27;&#123; print v1,v2 &#125;&#x27; v1=$var1 v2=$var2</span><br></pre></td></tr></table></figure>

<p>当输入来自于文件时使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123; print v1,v2 &#125;&#x27; v1=$var1 v2=$var2 filename</span><br></pre></td></tr></table></figure>

<p>以上方法中，变量之间用空格分隔作为awk的命令行参数跟随在BEGIN、{}和END语句块之后。</p>
<h2 id="查找进程pid"><a href="#查找进程pid" class="headerlink" title="查找进程pid"></a>查找进程pid</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -antup | grep 7770 | awk &#x27;&#123; print $NF NR&#125;&#x27; | awk &#x27;&#123; print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
