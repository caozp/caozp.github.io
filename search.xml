<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jenkins 声明式pipeline语法整理</title>
    <url>/posts/b9d9f13/</url>
    <content><![CDATA[<h1 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h1><p>顶层必须是pipeline,然后pipeline下面包含的是section。常见的section如下</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent&#123;&#125;</span><br><span class="line">    environment&#123;&#125;</span><br><span class="line">    triggers&#123;&#125;</span><br><span class="line">    options&#123;&#125;</span><br><span class="line">    parameters&#123;&#125;</span><br><span class="line">    tools&#123;&#125;</span><br><span class="line">    stages&#123;&#125;</span><br><span class="line">    post&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="section"><a href="#section" class="headerlink" title="section"></a>section</h1><h2 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h2><p>指定整个流水线或特定阶段将在jenkins环境中执行的位置。</p>
<p>可选值:</p>
<ul>
<li>any 在任何可用的节点上执行。</li>
<li>none 没有指定agent的时候默认。</li>
<li>docker 镜像</li>
<li>label 特定的label名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    //agent any</span><br><span class="line">    //agent &#123; label &#x27;LABEL&#x27;&#125;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123;</span><br><span class="line">            label &#x27;docker&#x27;</span><br><span class="line">            image &#x27;ubuntu:20.04&#x27;</span><br><span class="line">            args &#x27;-u root&#x27;</span><br><span class="line">            alwaysPull false</span><br><span class="line">            registryUrl &#x27;registry.com&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&#x27;build&#x27;) &#123;</span><br><span class="line">            agent &#123; label &#x27;LABEL&#x27; &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;abc&quot;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        stage(&#x27;deploy&#x27;)&#123;</span><br><span class="line">            agent &#123;</span><br><span class="line">                docker &#123;</span><br><span class="line">                    image &#x27;registry.cn-hangzhou.aliyuncs.com/mckj/ansible&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;通过ansbile进行部署&quot;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p>这些阶段根据流水线或阶段的完成情况而 运行(取决于流水线中post部分的位置)</p>
<ul>
<li>success 成功状态会执行</li>
<li>failure 失败状态会执行</li>
<li>always 总是会执行</li>
<li>aborted 中断状态会执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post &#123;</span><br><span class="line">    success &#123;</span><br><span class="line">        sh &quot;echo 成功了&quot;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    always &#123;</span><br><span class="line">        sh &quot;echo always&quot;</span><br><span class="line">        cleanWs()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>为所有步骤设置环境变量，或者是特定阶段的步骤。这取决于 environment 指令在流水线内的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                ACCESS_KEY = credentials(&#x27;my-secret-text&#x27;) </span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;printenv&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该指令还支持一种特殊的辅助方法credentials()。</p>
<p>该方法可用于在Jenkins环境中通过标识符访问预定义的凭证。</p>
<p>支持<strong>Secret Text，Secret Field，Username and password，SSH with Private Key</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; </span><br><span class="line">        CC = &#x27;clang&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            environment &#123; </span><br><span class="line">                AN_ACCESS_KEY = credentials(&#x27;my-predefined-secret-text&#x27;) </span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;printenv&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&#x27;Example Username/Password&#x27;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                SERVICE_CREDS = credentials(&#x27;my-predefined-username-password&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;Service user is $SERVICE_CREDS_USR&quot;&#x27;</span><br><span class="line">                sh &#x27;echo &quot;Service password is $SERVICE_CREDS_PSW&quot;&#x27;</span><br><span class="line">                sh &#x27;curl -u $SERVICE_CREDS https://myservice.example.com&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&#x27;Example SSH Username with private key&#x27;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                SSH_CREDS = credentials(&#x27;my-predefined-ssh-creds&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;echo &quot;SSH private key is located at $SSH_CREDS&quot;&#x27;</span><br><span class="line">                sh &#x27;echo &quot;SSH user is $SSH_CREDS_USR&quot;&#x27;</span><br><span class="line">                sh &#x27;echo &quot;SSH passphrase is $SSH_CREDS_PSW&quot;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><p>用来配置Jenkins应用自身的一些配置项，常用的参数有如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options &#123;</span><br><span class="line"></span><br><span class="line">    //表示保留10次构建历史</span><br><span class="line">    buildDiscarder(logRotator(numToKeepStr: &#x27;10&#x27;))</span><br><span class="line">    </span><br><span class="line">    //不允许同时执行流水线，被用来防止同时访问共享资源等</span><br><span class="line">    disableConcurrentBuilds()</span><br><span class="line">    </span><br><span class="line">    //项目构建超时时间</span><br><span class="line">    timeout(time: 10, unit: &#x27;MINUTES&#x27;)</span><br><span class="line">    </span><br><span class="line">    //输出构建的时间信息</span><br><span class="line">    timestamps()</span><br><span class="line">    </span><br><span class="line">    //跳过默认的代码检出</span><br><span class="line">    skipDefaultCheckout()</span><br><span class="line">    </span><br><span class="line">    //指定代码检出到$WORKSPACE的子目录</span><br><span class="line">    checkoutToSubdirectory(&#x27;testdir&#x27;)</span><br><span class="line">    </span><br><span class="line">    //重试</span><br><span class="line">    retry(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用于配置stage的指令有retry, timeout, or timestamps</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">    options &#123;</span><br><span class="line">        timeout(time: 1, unit: &#x27;HOURS&#x27;)</span><br><span class="line">        retry(3)</span><br><span class="line">        timestamps()</span><br><span class="line">    &#125;</span><br><span class="line">    steps &#123;</span><br><span class="line">        echo &#x27;Hello World&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Parameters构建变量"><a href="#Parameters构建变量" class="headerlink" title="Parameters构建变量"></a>Parameters构建变量</h2><p>支持的参数</p>
<ul>
<li>text</li>
<li>string</li>
<li>booleanParam</li>
<li>choice</li>
<li>password</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(name: &#x27;PERSON&#x27;, defaultValue: &#x27;Mr Jenkins&#x27;, description: &#x27;Who should I say hello to?&#x27;)</span><br><span class="line"></span><br><span class="line">        text(name: &#x27;BIOGRAPHY&#x27;, defaultValue: &#x27;&#x27;, description: &#x27;Enter some information about the person&#x27;)</span><br><span class="line"></span><br><span class="line">        booleanParam(name: &#x27;TOGGLE&#x27;, defaultValue: true, description: &#x27;Toggle this value&#x27;)</span><br><span class="line"></span><br><span class="line">        choice(name: &#x27;CHOICE&#x27;, choices: [&#x27;One&#x27;, &#x27;Two&#x27;, &#x27;Three&#x27;], description: &#x27;Pick something&#x27;)</span><br><span class="line"></span><br><span class="line">        password(name: &#x27;PASSWORD&#x27;, defaultValue: &#x27;SECRET&#x27;, description: &#x27;Enter a password&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;Hello $&#123;params.PERSON&#125;&quot;</span><br><span class="line"></span><br><span class="line">                echo &quot;Biography: $&#123;params.BIOGRAPHY&#125;&quot;</span><br><span class="line"></span><br><span class="line">                echo &quot;Toggle: $&#123;params.TOGGLE&#125;&quot;</span><br><span class="line"></span><br><span class="line">                echo &quot;Choice: $&#123;params.CHOICE&#125;&quot;</span><br><span class="line"></span><br><span class="line">                echo &quot;Password: $&#123;params.PASSWORD&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="triggers触发器"><a href="#triggers触发器" class="headerlink" title="triggers触发器"></a>triggers触发器</h2><p>定义流水线触发的一些机制与条件，流水线支持的触发器有三种：cron, pollSCM 和 upstream<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">triggers&#123;</span><br><span class="line">   cron(&#x27;H */4 * * 1-5&#x27;) //周一到周五每隔四小时执行构建</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>H关键字，H亦即Hash，表示当前位置跨度范围内随机一值</p>
<p>jenkins定时语法:</p>
<table>
<thead>
<tr>
<th align="left">MINUTE</th>
<th align="left">HOUR</th>
<th align="left">DOM</th>
<th align="left">MONTH</th>
<th align="left">DOW</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Minutes within the hour (0–59)</td>
<td align="left">The hour of the day (0–23)</td>
<td align="left">The day of the month (1–31)</td>
<td align="left">The month (1–12)</td>
<td align="left">The day of the week (0–7) where 0 and 7 are Sunday.</td>
</tr>
</tbody></table>
<ul>
<li>星号:匹配所有值</li>
<li>M-N: 匹配M到N之间的值</li>
<li>M-N&#x2F;X or *&#x2F;X:  范围内X值为步长</li>
<li>A,B: A或者B</li>
</ul>
<h2 id="tools构建工具"><a href="#tools构建工具" class="headerlink" title="tools构建工具"></a>tools构建工具</h2><p>定义部署流程中常用的一些工具，这些工具在管理Jenkins—&gt;Global Tool Configuration中添加，然后在项目中引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven &#x27;maven&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Example&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;mvn --version&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h2><p>包含一系列一个或多个 stage 指令</p>
<h3 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h3><p>stage用来描述大部分工作所在的位置</p>
<h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><p>标识阶段之中具体的构建步骤，至少包含一个步骤，<strong>在stage中有且只能有一个steps</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage(&#x27;名称&#x27;)&#123;</span><br><span class="line">    steps&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel并行"><a href="#parallel并行" class="headerlink" title="parallel并行"></a>parallel并行</h3><p>parallel关键字用于指定某些阶段可以并行的情况。一个阶段必须只有一个 steps 或 parallel 的阶段</p>
<p>通过添加 failFast true 到包含 parallel的 stage 中， 当其中一个进程失败时，你可以强制所有的 parallel 阶段都被终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent none</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;clean&#x27;) &#123;</span><br><span class="line">            failFast true</span><br><span class="line">            parallel&#123;</span><br><span class="line">                stage(&#x27;Node_1&#x27;)&#123;</span><br><span class="line">                    agent &#123; label &#x27;Node_1&#x27; &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                      sh &#x27;echo &quot;task1&quot;&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                stage(&#x27;Node_2&#x27;) &#123;</span><br><span class="line">                    agent &#123; label &#x27;Node_2&#x27; &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                       sh &#x27;echo &quot;task2&quot;&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令when"><a href="#指令when" class="headerlink" title="指令when"></a>指令when</h3><p>允许流水线根据指定条件来确定是否执行该阶段</p>
<ol>
<li><p>branch 当正在构建的分支与给定的分支模式（ANT 样式路径 glob）匹配时执行该阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when &#123; branch &#x27;master&#x27; &#125;</span><br><span class="line">可选参数比较器</span><br><span class="line">when &#123; </span><br><span class="line">    branch pattern: &quot;release-\\d+&quot;, comparator: &quot;REGEXP&quot;</span><br><span class="line"></span><br><span class="line">    branch pattern: &quot;release-*&quot;, comparator: &quot;GLOB&quot; //Ant风格路径</span><br><span class="line"></span><br><span class="line">    branch pattern: &quot;release&quot;, comparator: &quot;EQUALS&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>environment 当指定的环境变量设置为给定值时执行该阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">    when &#123;</span><br><span class="line">        branch &#x27;production&#x27;</span><br><span class="line">        environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;production&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    steps &#123;</span><br><span class="line">        echo &#x27;Deploying&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>equals 当期望值等于实际值时执行阶段，例如：when { equals expected: 2, actual: currentBuild.number }</p>
</li>
<li><p>not 当嵌套条件为假时执行该阶段。 必须包含一个条件。例如：when { not { branch ‘master’ } }</p>
</li>
<li><p>expression 当指定的 Groovy 表达式计算结果为真时执行该阶段，例如：when { expression { return params.DEBUG_BUILD } } 。请注意，当从表达式返回字符串时，它们必须转换为布尔值或返回空值以计算结果为假。</p>
</li>
<li><p>allOf,anyOf 当一个或者多个条件为真时 如when { anyOf { branch ‘master’; branch ‘staging’ } }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage(&#x27;Example Deploy&#x27;) &#123;</span><br><span class="line">    when &#123;</span><br><span class="line">        branch &#x27;production&#x27;</span><br><span class="line">        anyOf &#123;</span><br><span class="line">            environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;production&#x27;</span><br><span class="line">            environment name: &#x27;DEPLOY_TO&#x27;, value: &#x27;staging&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    steps &#123;</span><br><span class="line">        echo &#x27;Deploying&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>triggeredBy 根据触发原因</p>
</li>
</ol>
<ul>
<li>when { triggeredBy ‘SCMTrigger’ }</li>
<li>when { triggeredBy ‘TimerTrigger’ }</li>
<li>when { triggeredBy ‘BuildUpstreamCause’ }</li>
<li>when { triggeredBy cause: “UserIdCause”, detail: “vlinde” }</li>
</ul>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>curl命令进行网络请求</title>
    <url>/posts/abc9965/</url>
    <content><![CDATA[<p>curl命令 是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。</p>
<span id="more"></span>

<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>使用选项-O将下载的数据写入到文件，文件与远端服务器上的文件名保持一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -O http://example.com/text.iso</span><br></pre></td></tr></table></figure>
<p>或者使用-o(等于–output，把输出写到该文件中)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o filename.iso http://example.com/test.iso --progress</span><br><span class="line">######################################### 100.0%</span><br></pre></td></tr></table></figure>
<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>curl能够从特定的文件偏移处继续下载，它可以通过指定一个偏移量来下载部分文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl URL/File -C 偏移量</span><br><span class="line"></span><br><span class="line">#偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -：</span><br><span class="line">curl -C -URL</span><br></pre></td></tr></table></figure>

<h2 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h2><p>-H 参数添加 HTTP 请求的标头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &#x27;Accept-Language: en-US&#x27; https://example.com</span><br><span class="line"></span><br><span class="line">curl -H &#x27;Accept-Language: en-US&#x27; -H &#x27;Content-Type: application/json&#x27; https://example.com</span><br></pre></td></tr></table></figure>
<h2 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h2><p>使用curl选项 -u 可以完成HTTP或者FTP的认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -u username:password http://example.com</span><br></pre></td></tr></table></figure>
<p>也有将认证信息放在请求头里的,例如github的api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L -H &quot;Accept: application/vnd.github+json&quot; -H &quot;Authorization: Bearer &lt;YOUR-TOKEN&gt;&quot; https://api.github.com/repos/OWNER/REPO/pulls</span><br></pre></td></tr></table></figure>

<h2 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h2><p>使用curl命令时，它默认使用GET方法进行HTTP请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;http://www.example.com&quot;    # 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span><br><span class="line">curl -i &quot;http://www.example.com&quot; # 显示全部信息</span><br><span class="line">curl -l &quot;http://www.example.com&quot; # 显示页面内容</span><br><span class="line">curl -v &quot;http://www.example.com&quot; # 显示get请求全过程解析</span><br></pre></td></tr></table></figure>

<h2 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h2><p>但是如果是Post请求时，使用-X</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -d &quot;param1=value1&amp;param2=value2&quot; &quot;http://www.example.com/login&quot;</span><br><span class="line"></span><br><span class="line">$ curl -d&#x27;login=emma＆password=123&#x27; -X POST https://example.com/login</span><br><span class="line"># 或者</span><br><span class="line">$ curl -d &#x27;login=emma&#x27; -d &#x27;password=123&#x27; -X POST  https://example.com/login</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>添加-d 发送 POST 请求的数据体</p>
<p>发送Json格式的Post请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -l -H &quot;Content-type: application/json&quot; -X POST -d &#x27;&#123;&quot;phone&quot;:&quot;13888888888&quot;,&quot;password&quot;:&quot;test&quot;&#125;&#x27; http://example.com/apis/users.json</span><br></pre></td></tr></table></figure>

<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>使用-T 指定要上传的文件名,同时发送PUT请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -u name:password -X PUT url -T ./test.txt</span><br></pre></td></tr></table></figure>
<p>或者使用-F。-F 选项适用于模拟表单提交，将文件作为表单的一部分上传；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -F &quot;file=@/path/to/file.txt&quot; https://example.com/upload</span><br><span class="line"></span><br><span class="line">curl -F &#x27;file=@photo.png;type=image/png&#x27; https://example.com/profile</span><br><span class="line"># 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为 application/octet-stream。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用以及next主题配置</title>
    <url>/posts/177574ba/</url>
    <content><![CDATA[<p>参考<a href="https://blog.csdn.net/as480133937/article/details/100138838">文章</a></p>
<span id="more"></span>
<p>添加了本地搜索<br>修改文章链接<br>添加live2d</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>hexo new “name”       # 新建文章<br>hexo new page “name”  # 新建页面<br>hexo g                # 生成页面<br>hexo d                # 部署<br>hexo g -d             # 生成页面并部署<br>hexo s                # 本地预览<br>hexo clean            # 清除缓存和已生成的静态文件<br>hexo help             # 帮助</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>find查找文件</title>
    <url>/posts/89021aa2/</url>
    <content><![CDATA[<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<span id="more"></span>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find(选项)(参数)</span><br><span class="line"></span><br><span class="line">比较常用的参数:</span><br><span class="line">-prune：不寻找字符串作为寻找文件或目录的范本样式;</span><br><span class="line">-maxdepth&lt;目录层级&gt;：设置最大目录层级；</span><br><span class="line">-mindepth&lt;目录层级&gt;：设置最小目录层级；</span><br><span class="line">-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；</span><br><span class="line">-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</span><br><span class="line">-size&lt;文件大小&gt;：查找符合指定的文件大小的文件；</span><br><span class="line">-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式</span><br><span class="line">-depth：从指定目录下最深层的子目录开始查找；</span><br><span class="line">-empty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；</span><br><span class="line">-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基于名字查找-name"><a href="#基于名字查找-name" class="headerlink" title="基于名字查找-name"></a>基于名字查找-name</h3><p>在<code>/home</code>目录下查找以.txt结尾的文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<p>在当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br></pre></td></tr></table></figure>

<h3 id="基于路径查找-path"><a href="#基于路径查找-path" class="headerlink" title="基于路径查找-path"></a>基于路径查找-path</h3><p>匹配文件路径或者文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure>
<p>查找路径下所有example&#x2F;pubspec.yaml的文件,可以看到-path是支持Ant风格路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -path &quot;**/example/pubspec.yaml&quot;</span><br></pre></td></tr></table></figure>
<h3 id="否定参数"><a href="#否定参数" class="headerlink" title="否定参数"></a>否定参数</h3><p>找出&#x2F;home下不是以.txt结尾的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br><span class="line"></span><br><span class="line">除此之外，也可以用not</span><br><span class="line">find /path/to/folder -type f -not -path &#x27;*/.git/*&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="基于正则表达式匹配文件路径"><a href="#基于正则表达式匹配文件路径" class="headerlink" title="基于正则表达式匹配文件路径"></a>基于正则表达式匹配文件路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>

<p>同上，但忽略大小写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>

<h3 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h3><p>向下最大深度限制为3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -maxdepth 3 -type f</span><br></pre></td></tr></table></figure>

<p>搜索出深度距离当前目录至少2个子目录的所有文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -mindepth 2 -type f</span><br></pre></td></tr></table></figure>

<h3 id="根据文件大小进行匹配"><a href="#根据文件大小进行匹配" class="headerlink" title="根据文件大小进行匹配"></a>根据文件大小进行匹配</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size 文件大小单元</span><br></pre></td></tr></table></figure>

<p>文件大小单元：</p>
<ul>
<li><strong>b</strong>  —— 块（512字节）</li>
<li><strong>c</strong>  —— 字节</li>
<li><strong>w</strong>  —— 字（2字节）</li>
<li><strong>k</strong>  —— 千字节</li>
<li><strong>M</strong>  —— 兆字节</li>
<li><strong>G</strong>  —— 吉字节</li>
</ul>
<p>搜索大于10KB的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size +10k</span><br></pre></td></tr></table></figure>

<p>搜索小于10KB的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size -10k</span><br></pre></td></tr></table></figure>

<p>搜索等于10KB的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size 10k</span><br></pre></td></tr></table></figure>

<h3 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h3><p>删除当前目录下所有.txt文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -delete</span><br></pre></td></tr></table></figure>

<h3 id="借助-exec选项与其他命令结合使用"><a href="#借助-exec选项与其他命令结合使用" class="headerlink" title="借助-exec选项与其他命令结合使用"></a>借助<code>-exec</code>选项与其他命令结合使用</h3><p>找出当前目录下所有root的文件，并把所有权更改为用户tom</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -user root -exec chown tom &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上例中， <strong>{}</strong>  用于与 <strong>-exec</strong> 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</p>
<p>找出自己家目录下所有的.txt文件并删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find $HOME/. -name &quot;*.txt&quot; -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上例中， <strong>-ok</strong> 和 <strong>-exec</strong> 行为一样，不过它会给出提示，是否执行相应的操作。</p>
<p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; /all.txt</span><br></pre></td></tr></table></figure>

<p>将30天前的.log文件移动到old目录中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br></pre></td></tr></table></figure>

<p>找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-exec ./text.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="搜索但跳过指定的目录"><a href="#搜索但跳过指定的目录" class="headerlink" title="搜索但跳过指定的目录"></a>搜索但跳过指定的目录</h3><p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>

<blockquote>
<p>:warning: .&#x2F;sk 不能写成 .&#x2F;sk&#x2F; ，否则没有作用。</p>
</blockquote>
<p>忽略两个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . \( -path ./sk -o  -path ./st \) -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>

<blockquote>
<p>:warning: 如果写相对路径必须加上<code>./</code></p>
</blockquote>
<h3 id="find其他技巧收集"><a href="#find其他技巧收集" class="headerlink" title="find其他技巧收集"></a>find其他技巧收集</h3><p>要列出所有长度为零的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -empty</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本基础知识点</title>
    <url>/posts/acba6a0c/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>shell变量定义要求:</p>
<ul>
<li>首个字符必须为字母</li>
<li>中间不能有空格，可以使用下划线，<strong>等号左右也不能有空格</strong></li>
<li>不能使用标点符号</li>
<li>不能使用bash里的关键字</li>
</ul>
<span id="more"></span>

<p>访问:在 Shell 中，访问变量的值,需要使用 $ 符号加上变量名即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_var=&quot;this is a new line&quot;</span><br><span class="line">echo $your_var</span><br><span class="line">echo $&#123;your_var&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个变量未设置，那么就使用默认值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;parameter-default&#125; 或者 <span class="variable">$&#123;parameter:-default&#125;</span></span></span><br><span class="line"></span><br><span class="line">default=$&#123;HOME-`whoami`&#125;</span><br><span class="line">echo $default</span><br></pre></td></tr></table></figure>

<h2 id="只读变量readonly"><a href="#只读变量readonly" class="headerlink" title="只读变量readonly"></a>只读变量readonly</h2><p>在变量前加上readonly，变量不可以被重新赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readonly github</span><br><span class="line">github=&quot;https://www.github.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="删除变量unset"><a href="#删除变量unset" class="headerlink" title="删除变量unset"></a>删除变量unset</h2><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var=&quot;abc&quot;</span><br><span class="line">unset var</span><br><span class="line">echo $var  # unset后的变量,再次访问就为空</span><br></pre></td></tr></table></figure>

<h2 id="命令结果赋值给变量"><a href="#命令结果赋值给变量" class="headerlink" title="命令结果赋值给变量"></a>命令结果赋值给变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variable=`command`</span><br><span class="line">variable=$(command)</span><br></pre></td></tr></table></figure>
<p>例子1.获取远程的所有分支名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">REMOTE_BRANCHES=$(git branch -r)</span><br><span class="line">for remote_branch in $&#123;REMOTE_BRANCHES[*]&#125;</span><br><span class="line">do</span><br><span class="line">  echo $&#123;remote_branch&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例子2.获取当前的分支名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Default_Branch=$(git rev-parse --abbrev-ref HEAD)</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>使用单引号和使用双引号也是有区别的。<strong>单引号不会转义，原样输出; 双引号会读取变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">字符串为双引号时</span><br><span class="line">export STRING=&quot;$HOME&quot;</span><br><span class="line">echo &#x27;$STRING&#x27;    -&gt; $STRING</span><br><span class="line">export STRING=&quot;$HOME&quot;</span><br><span class="line">echo &quot;$STRING&quot;    -&gt; /home/apple</span><br><span class="line"></span><br><span class="line">字符串为单引号时</span><br><span class="line">export STRING=&#x27;$HOME&#x27;</span><br><span class="line">echo &#x27;$STRING&#x27;    -&gt; $STRING</span><br><span class="line">export STRING=&#x27;$HOME&#x27;</span><br><span class="line">echo &quot;$STRING&quot;    -&gt; $HOME</span><br></pre></td></tr></table></figure>

<h2 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h2><p>在Shell中，转义字符是一个特殊字符，用于表示一些特殊的含义。例如插入换行符、制表符、引号等。在Shell命令中，可以使用<strong>反斜杠</strong>来指示后面的字符应该被当做普通字符处理，而不是具有特殊含义。</p>
<p>以下是一些常见的转义字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\n：表示换行符，用于在字符串中插入一个新行。</span><br><span class="line">\t：表示制表符，用于在字符串中插入一个制表符。</span><br><span class="line">\&quot;：表示双引号，用于在字符串中插入一个双引号。</span><br><span class="line">\&#x27;：表示单引号，用于在字符串中插入一个单引号。</span><br><span class="line">\\：表示反斜杠，用于在字符串中插入一个反斜杠。</span><br></pre></td></tr></table></figure>
<p>例如，如果我们想在一个字符串中插入一个双引号，可以使用转义字符\来表示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export STRING=&quot;\&quot;hello\&quot; world&quot;</span><br><span class="line">echo $STRING    </span><br><span class="line">&quot;hello&quot; world</span><br></pre></td></tr></table></figure>
<p>又或者，我们想在字符串中加入换行符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STRING=&quot;hello\n world&quot;</span><br><span class="line">-&gt; % echo $STRING</span><br><span class="line">hello</span><br><span class="line"> world</span><br></pre></td></tr></table></figure>

<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#var&#125; 可以表示字符串长度，也就是字符的个数</span></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% string=<span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span></span></span><br><span class="line">10 </span><br></pre></td></tr></table></figure>

<h2 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h2><h3 id="按下标切割"><a href="#按下标切割" class="headerlink" title="按下标切割"></a>按下标切割</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string: start&#125;</span>        </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string: start :length&#125;</span> </span><br><span class="line">start -- 起始位置，从左边开始，字符串第一个索引是0</span><br><span class="line">length -- 长度。没有length的时候，默认到结尾</span><br></pre></td></tr></table></figure>
<p>从第二个字符截取到结尾</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;This is a line&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string:2&#125;        -&gt;  is is a line</span></span><br></pre></td></tr></table></figure>
<p>从第二个字符截取4个字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;This is a line&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string:2:4&#125;        -&gt;  is i</span></span><br></pre></td></tr></table></figure>
<p><strong>也可以从右边下标开始计数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;string: 0-start :length&#125;</span></span><br></pre></td></tr></table></figure>
<p>从右边开始计数时，起始下标数字是 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % string=&quot;This is a line&quot;</span><br><span class="line"></span><br><span class="line">-&gt; % echo $&#123;string:0-4&#125;</span><br><span class="line">line   # 表示截取最末尾四个字符</span><br><span class="line">-&gt; % echo $&#123;string:0-4:2&#125;</span><br><span class="line">li</span><br><span class="line">-&gt; % echo $&#123;string:0-1&#125;</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<h3 id="匹配Pattern切割"><a href="#匹配Pattern切割" class="headerlink" title="匹配Pattern切割"></a>匹配Pattern切割</h3><p>${var#Pattern}, ${var##Pattern}：删除从$var前端开始的最短或最长匹配Pattern的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;string#*chars&#125; </span><br><span class="line">从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符</span><br><span class="line"></span><br><span class="line">$&#123;string##*chars&#125; </span><br><span class="line">从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</span><br><span class="line"></span><br><span class="line">$&#123;string%chars*&#125;  </span><br><span class="line">从 string 字符串第一次出现 *chars 的位置开始，截取 chars 左边的所有字符。</span><br><span class="line"></span><br><span class="line">$&#123;string%%chars*&#125; </span><br><span class="line">从 string 字符串最后一次出现 *chars 的位置开始，截取 chars 左边的所有字符。</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例，按 _ 分割</span><br><span class="line">var=1_2_3_4_5</span><br><span class="line"></span><br><span class="line">echo $&#123;var#*_&#125;    结果为2_3_4_5  去掉 从左边开始 到第一个字符 &#x27;_&#x27; 之间的内容</span><br><span class="line"></span><br><span class="line">echo $&#123;var##*_&#125;   结果为5        去掉 从左边开始 到最后一个字符 &#x27;_&#x27; 之间的内容</span><br><span class="line"></span><br><span class="line">echo $&#123;var%_*&#125;    结果为1_2_3_4  去掉 从右边开始 到第一个字符 &#x27;_&#x27; 之间的内容</span><br><span class="line"></span><br><span class="line">echo $&#123;var%%_*&#125;   结果为1        去掉 从右边开始 到最后一个字符 &#x27;_&#x27; 之间的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">练习:</span><br><span class="line">file=a/b/c/d/e</span><br><span class="line">echo $&#123;file##*/&#125;</span><br><span class="line">echo $&#123;file#*/&#125;</span><br><span class="line">echo $&#123;file%%/*&#125;</span><br><span class="line">echo $&#123;file%/*&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cut切割"><a href="#cut切割" class="headerlink" title="cut切割"></a>cut切割</h3><p>案例1，使用cut命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; cat /etc/passwd|head -n 5|cut -d : -f 1|sed -n &quot;1p&quot;</span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<h3 id="awk切割"><a href="#awk切割" class="headerlink" title="awk切割"></a>awk切割</h3><p>案例1，使用awk命令,根据github pr获取pr对应的改动文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Accept: application/vnd.github+json&quot; -H &quot;Authorization: Bearer $1&quot; https://url/pulls/$2/files | grep &#x27;&quot;filename&quot;:&#x27;|awk -F &#x27;&quot;&#x27; &#x27;&#123;print $4&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var=$(cat &lt;&lt;- EOF</span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line">echo &quot;$var&quot;  # 此处一定要加引号，否则只会单行显示</span><br><span class="line"></span><br><span class="line">#生成json数据后，通过post命令请求url</span><br><span class="line">generate_post_data()</span><br><span class="line">&#123;</span><br><span class="line">cat &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">&quot;tag_name&quot;: &quot;$tag&quot;,</span><br><span class="line">&quot;target_commitish&quot;: &quot;$branch&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line">curl -H &quot;$AUTH&quot; -H &quot;Content-Type: application/json&quot; --request POST --data &quot;$(generate_post_data)&quot; &quot;https://github.com/api/v3/repos/$owner/$repo/releases&quot;</span><br></pre></td></tr></table></figure>
<p>EOF是“End Of File”的缩写，表示文件结束的标记。在Shell中，EOF通常用于指定一个多行输入的结束标记，例如在输入脚本或命令时。</p>
<p>在Shell中，EOF后面的文本会被视为输入的内容，直到遇到一个与EOF内容相同的行为止。这个标记通常用于输入多行文本，例如在创建一个新文件时，需要输入文件内容，可以使用EOF来指定输入的结束标记。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>用括号来表示数组，数组元素用”<strong>空格</strong>“符号分割开</p>
<p>array&#x3D;(v1 v2 v3 v4)</p>
<p>读取某个元素: ${数组名[下标]}</p>
<p>使用 @ 符号可以获取数组中的所有元素: ${array[@]}</p>
<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>我们要获取数组的长度，<strong>我们需要使用 @ 或者 * 将数组扩展成列表，然后再次使用 # 获取数组的长度。</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;#array_name[@]&#125;</span><br><span class="line">$&#123;#array_name[*]&#125;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % array=(a b c d e f)</span><br><span class="line">-&gt; % echo $&#123;array[3]&#125;       </span><br><span class="line">d</span><br><span class="line">-&gt; % echo $&#123;array[@]&#125;       </span><br><span class="line">a b c d e f</span><br><span class="line">-&gt; % echo $&#123;#array[@]&#125;</span><br><span class="line">6</span><br><span class="line">-&gt; % echo $&#123;#array[*]&#125;</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了管道</p>
<p>Linux 管道使用竖线|连接多个命令，这被称为管道符。Linux 管道的具体语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 [ | commandN... ]</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -al|grep file</span><br></pre></td></tr></table></figure>

<p>使用xargs占位符, 找到文件中的minSdkVersion并替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;minSdkVersion&#x27; build.gradle |xargs -I &#123;&#125; sed -i &quot;s/&#123;&#125;/minSdkVersion 23/g&quot; build.gradle</span><br></pre></td></tr></table></figure>

<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>重定向操作符&gt;将命令与文件连接起来，用文件来接收命令的输出；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command &gt; file</span><br></pre></td></tr></table></figure>
<p>在输出重定向中，&gt;代表的是覆盖，&gt;&gt;代表的是追加。</p>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 &lt; input.txt | command2</span><br></pre></td></tr></table></figure>
<p>示例:使用 tr 命令从 os.txt 文件中获取输入，然后通过管道将输出发送给 sort 或 uniq 等命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; $ cat os.txt</span><br><span class="line">redhat</span><br><span class="line">suse</span><br><span class="line">centos</span><br><span class="line">ubuntu</span><br><span class="line">solaris</span><br><span class="line">hp-ux</span><br><span class="line">fedora</span><br><span class="line">centos</span><br><span class="line">redhat</span><br><span class="line">hp-ux</span><br><span class="line">-&gt; $ tr a-z A-Z &lt;os.txt | sort</span><br><span class="line">CENTOS</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br><span class="line">-&gt; $ tr a-z A-Z &lt;os.txt | sort | uniq</span><br><span class="line">CENTOS</span><br><span class="line">FEDORA</span><br><span class="line">HP-UX</span><br><span class="line">REDHAT</span><br><span class="line">SOLARIS</span><br><span class="line">SUSE</span><br><span class="line">UBUNTU</span><br></pre></td></tr></table></figure>

<h2 id="标准错误与标准输出"><a href="#标准错误与标准输出" class="headerlink" title="标准错误与标准输出"></a>标准错误与标准输出</h2><p>Linux 程序在执行任何形式的 I&#x2F;O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。</p>
<p>stdin(0)、stdout(1)、stderr(2) 默认都是打开的，在重定向的过程中，0、1、2 这三个文件描述符可以直接使用。</p>
<h3 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; $ ls java  #先预览一下错误信息</span><br><span class="line">ls: 无法访问java: 没有那个文件或目录</span><br><span class="line">-&gt; $ ls java 2&gt;err.log  #重定向</span><br><span class="line">-&gt; $ cat err.log  #查看文件</span><br><span class="line">ls: 无法访问java: 没有那个文件或目录</span><br></pre></td></tr></table></figure>

<h3 id="同时保存标准输出和标准输入"><a href="#同时保存标准输出和标准输入" class="headerlink" title="同时保存标准输出和标准输入"></a>同时保存标准输出和标准输入</h3><p>2&gt;&amp;1, 表示2的输出重定向等同于1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls java &gt;out.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h3 id="什么是-dev-null"><a href="#什么是-dev-null" class="headerlink" title="什么是&#x2F;dev&#x2F;null"></a>什么是&#x2F;dev&#x2F;null</h3><p>&#x2F;dev&#x2F;null表示空设备，在Unix和类Unix系统中使用。它被用作一个虚拟的黑洞，任何写入&#x2F;dev&#x2F;null的数据都会被丢弃，任何从&#x2F;dev&#x2F;null读取的操作都会立即返回一个空值。因此，&#x2F;dev&#x2F;null经常被用来丢弃不需要的输出或者作为一个空的输入源</p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>Shell 变量的作用域可以分为三种：</p>
<ul>
<li>全局变量：当前 shell 进程中使用的变量，无前缀词修饰直接赋值的变量，如 FOO&#x3D;bar</li>
<li>环境变量：可以在子shell中使用的变量，使用 export 导出，如 export FOO&#x3D;bar</li>
<li>局部变量：使用 local 修饰，只能在函数内部使用。</li>
</ul>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% AGE=10</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">echo</span> <span class="variable">$AGE</span></span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>此时AGE是全局变量，而且，在子shell中也无法获取它的数值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % zsh              #zsh可以切换到子shell</span><br><span class="line">-&gt; % echo $AGE        #此时为空值</span><br><span class="line"></span><br><span class="line">#执行脚本也无法读到变量</span><br><span class="line">-&gt; % cat test.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo $AGE</span><br><span class="line"></span><br><span class="line">-&gt; % ./test.sh</span><br><span class="line">   #无结果</span><br></pre></td></tr></table></figure>
<p>我们看到，此时并没有获取到该变量的值。即，<strong>全局变量只能在当前 Shell 访问</strong></p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>要想变量的作用域仅限于函数内部，那么可以在定义时加上 local 命令，此时该变量就成了局部变量</p>
<p>新建一个脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义函数</span></span><br><span class="line">function func()&#123;</span><br><span class="line">	a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出函数内部的变量</span></span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<p>此时a输出为99。修改脚本,为变量a添加local修饰</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义函数</span></span><br><span class="line">function func()&#123;</span><br><span class="line">	local a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出函数内部的变量</span></span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<p>则此时a为空值</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>如果使用 export 命令将变量导出，那么它就在所有的子 Shell 中也有效了，这称为 “环境变量”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">export</span> AGE=10</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">cat</span> test.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $AGE</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% ./test.sh</span></span><br><span class="line">10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% zsh</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">echo</span> <span class="variable">$AGE</span></span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h2 id="系统环境变量"><a href="#系统环境变量" class="headerlink" title="系统环境变量"></a>系统环境变量</h2><p>我们可以通过<code>env</code>命令和<code>set</code>命令查看一些当前shell中存在的变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set 可以查看环境变量</span><br><span class="line">env 可以查看所有变量</span><br></pre></td></tr></table></figure>
<p>这其中有一些比较特殊的变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">OSTYPE    <span class="comment">#操作系统类型 x86_64</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">MACHTYPE  <span class="comment">#机器类型，识别系统的硬件类型。 如 darwin22.0</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PPID      <span class="comment">#一个进程的$PPID变量保存它的父进程的进程ID(pid)。</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">UID       <span class="comment">#用户ID号，这是当前用户的用户标识号，它在/etc/passwd文件中记录。或者(id -u)</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">USER</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PWD</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">LANG      <span class="comment">#默认的主语系变量  查看所有支持的语言-&gt;locale -a</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL     <span class="comment">#可以通过 cat /etc/shells  查看支持解释器</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PATH</span>      </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PS1      命令提示符设置。也就是[root@localhost ~ ]的设置。对于root用户是<span class="comment">#，对于普通用户是$</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">? 上个命令的退出状态，或函数的返回值。</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>shell 是指一个面向用户的命令接口，表现形式就是一个可以由用户录入的界面，这个界面也可以反馈运行信息</p>
<h2 id="查看当前shell"><a href="#查看当前shell" class="headerlink" title="查看当前shell"></a>查看当前shell</h2><p>在linux机器上，默认都是使用bash。而在mac机器上，默认的是zsh。</p>
<p>查看支持的shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">% <span class="built_in">cat</span> /etc/shells</span></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看默认的shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % echo $SHELL</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure>
<h2 id="login-shell与非login-Shell"><a href="#login-shell与非login-Shell" class="headerlink" title="login shell与非login Shell"></a>login shell与非login Shell</h2><h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>包含两种情况：</p>
<ol>
<li>直接通过终端输入帐号密码登录,或者ssh连接</li>
<li>使用 <code>su - username</code> 切换的用户</li>
</ol>
<p>登录式shell的配置文件以 <code>/etc/profile</code> 为入口，然后嵌套引入其他配置文件。<br><strong>常见的加载顺序</strong>通常为</p>
<ol>
<li>&#x2F;etc&#x2F;profile</li>
<li>&#x2F;etc&#x2F;bash.bashrc</li>
<li>~&#x2F;.bash_profile</li>
<li>~&#x2F;.bashrc</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在mac机器上准备两个文件，设置两个环境变量，然后远程ssh登陆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File1: .zprofile:</span><br><span class="line">export http_proxy=zprofile</span><br><span class="line">export AGE=20</span><br><span class="line"></span><br><span class="line">File2: .zshrc:</span><br><span class="line">export http_proxy=internet.com</span><br></pre></td></tr></table></figure>
<p>执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % echo $0</span><br><span class="line">-zsh    # 前面的 - 表示是login shell</span><br><span class="line">-&gt; % echo $AGE</span><br><span class="line">20</span><br><span class="line">-&gt; % echo $http_proxy</span><br><span class="line">http://internet.com</span><br></pre></td></tr></table></figure>
<p>可以看到，.zshrc中的http_proxy变量值覆盖了.zprofile的变量http_proxy值。得出.zshrc比.zprofile后加载</p>
<h3 id="非登陆式shell"><a href="#非登陆式shell" class="headerlink" title="非登陆式shell"></a>非登陆式shell</h3><p>包含这几种情况：</p>
<ol>
<li>su username</li>
<li>图形界面下打开的终端</li>
<li>执行脚本</li>
<li>其他任何bash实例</li>
</ol>
<p>通常的加载顺序为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.bashrc -&gt; /etc/bashrc -&gt; /etc/profile.d/*.sh</span><br></pre></td></tr></table></figure>

<h2 id="父shell与子shell"><a href="#父shell与子shell" class="headerlink" title="父shell与子shell"></a>父shell与子shell</h2><p>当在执行一个脚本时，父Shell会根据脚本程序的第一行 <code>#!</code> 之后指定的解释器开启一个 子Shell 环境，然后在子Shell中执行此脚本。<br>但是一旦，子Shell 中的脚本执行完毕，此子Shell随即结束，回到父Shell中，不会影响父Shell原本的环境。<br>也就是说export一个变量后，父shell是不会读取到该变量</p>
<h3 id="如何判断父shell与子shell"><a href="#如何判断父shell与子shell" class="headerlink" title="如何判断父shell与子shell?"></a>如何判断父shell与子shell?</h3><p>通过进程ID，执行ps -f</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ps -f</span><br><span class="line">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class="line">  501 14251 14250   0  3:25下午 ttys000    0:00.53 -zsh</span><br><span class="line">-&gt; % zsh                 # 可以通过这种方式开启一个子shell</span><br><span class="line">-&gt; % ps -f</span><br><span class="line">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class="line">  501 14251 14250   0  3:25下午 ttys000    0:00.53 -zsh</span><br><span class="line">  501 14448 14251   0  3:32下午 ttys000    0:00.20 zsh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; PS 命令:</span><br><span class="line">&gt; UID 程序被该UID所拥有</span><br><span class="line">&gt; PID 代表这个程序的ID</span><br><span class="line">&gt; PPID 代表其上级父程序的ID</span><br></pre></td></tr></table></figure>
<p>由上可以看到子shell还是一个非login shell</p>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux文件管理</title>
    <url>/posts/3fd89380/</url>
    <content><![CDATA[<h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p>在linux系统中，可以说一切（包括目录、普通文件、设备文件等）皆为文件。文件类型包含有普通文件、目录、字符设备文件、块设备文件、符号链接文件、管道文件等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -ls时，第一列(如lrwxr-xr-x)的第一个字符(l)就是用来区分文件类型的。</span><br><span class="line"></span><br><span class="line">常见的种类有:</span><br><span class="line">1.  d 表示是目录</span><br><span class="line">2.  - 表示是文件</span><br><span class="line">3.  l 表示为链接文件</span><br><span class="line">4.  b 表示块设备和其他外围设备</span><br><span class="line">5.  c 字符设备文件</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>通过如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ls -l /etc/localtime</span><br><span class="line">lrwxr-xr-x  1 root  wheel  39  5 23 14:10 /etc/localtime -&gt; /var/db/timezone/zoneinfo/Asia/Shanghai</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到&#x2F;etc&#x2F;localtime指向&#x2F;var&#x2F;db&#x2F;timezone&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai</p>
<p>在linux系统中，链接可分为两种:一种为硬链接，另一种为软链接或符号链接。</p>
<h3 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">硬链接  ln 源文件 目标文件 </span><br><span class="line">软链接  ln -s 源文件 目标文件 （目标文件不能事先存在）</span><br></pre></td></tr></table></figure>

<ul>
<li>源文件：指定链接的源文件。如果使用<code>-s</code>选项创建软链接，则“源文件”可以是文件或者目录。创建硬链接时，则“源文件”参数只能是文件。</li>
<li>目标文件：指定源文件的目标链接文件。</li>
</ul>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>在目录<code>/usr/liu</code>下建立一个符号链接文件abc，使它指向目录<code>/usr/mengqc/mub1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/mengqc/mub1 /usr/liu/abc</span><br></pre></td></tr></table></figure>
<p>也就是读取&#x2F;usr&#x2F;liu&#x2F;abc时，实际访问的是&#x2F;usr&#x2F;mengqc&#x2F;mub1</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>给文件创建硬链接，为 <code>myfile</code> 创建硬链接 <code>hard</code>，<code>myfile</code> 与 <code>hard</code> 的文件 <code>inode</code> 值相同，它指向了物理硬盘的一个区块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch myfile &amp;&amp; echo &quot;This is a plain text file.&quot; &gt; myfile</span><br><span class="line">$ cat myfile</span><br><span class="line">This is a plain text file.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ln myfile hard</span><br><span class="line">$ ls -li</span><br><span class="line">25869085 -rw-r--r--  2 unixzii  staff  27  7  8 17:39 hard</span><br><span class="line">25869085 -rw-r--r--  2 unixzii  staff  27  7  8 17:39 myfile</span><br><span class="line">                   链接数为2</span><br></pre></td></tr></table></figure>

<p>在默认情况下，ln命令创建硬链接。ln命令会增加链接数，rm命令会减少链接数。一个文件除非链接数为0，否则不会从文件系统中被物理地删除。</p>
<h1 id="文件属组和文件权限"><a href="#文件属组和文件权限" class="headerlink" title="文件属组和文件权限"></a>文件属组和文件权限</h1><p>一个文件对于不同属组，不同所有者有不同的读写权限。</p>
<p>文件的基本权限包含如下：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>含义</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读</td>
<td>4</td>
</tr>
<tr>
<td>w</td>
<td>写</td>
<td>2</td>
</tr>
<tr>
<td>x</td>
<td>执行</td>
<td>1</td>
</tr>
<tr>
<td>-</td>
<td>无</td>
<td>0</td>
</tr>
</tbody></table>
<p>文件属性第一列(如:lrwxr-xr-x)的第二到第十个字符(rwxr-x-wx)定义了不同用户组对该文件的访问权限</p>
<table>
<thead>
<tr>
<th>2-4字符</th>
<th>5-7字符</th>
<th>8-10字符</th>
</tr>
</thead>
<tbody><tr>
<td>文件所有者权限</td>
<td>文件所属组</td>
<td>其他用户组</td>
</tr>
</tbody></table>
<h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><p>想要对文件操作必须有对应的权限。</p>
<p>修改权限可以使用全数字的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 740 file </span><br></pre></td></tr></table></figure>

<p>或者,使用对对应组用户赋予对应权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u g o a 分别是user,group,other,all的意思。</span><br><span class="line">+,-,=代表增加权限，删除权限，或者直接赋于权限</span><br><span class="line">chmod u=rwx,g=rx,o=r  test1</span><br><span class="line">chmod u+rx test2</span><br><span class="line">chmod a-x  test3</span><br></pre></td></tr></table></figure>

<h2 id="修改所属用户与组"><a href="#修改所属用户与组" class="headerlink" title="修改所属用户与组"></a>修改所属用户与组</h2><p>可以修改文件的所属组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>type显示指定命令的类型</title>
    <url>/posts/784c8df/</url>
    <content><![CDATA[<h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><h2 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h2><ul>
<li>显示要查找的命令的信息。</li>
<li>控制查找范围和行为。</li>
<li>显示要查找的命令优先级最高的类型。</li>
</ul>
<span id="more"></span>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type [-afptP] name [name ...]</span><br><span class="line"></span><br><span class="line">name：要查找的命令，可以为多个。</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a：在环境变量PATH中查找并显示所有包含name的可执行文件路径；当&#x27;-p&#x27;选项没有同时给出时，如果在别名、关键字，函数，内建的信息中存在name，则一并显示。</span><br><span class="line">-f：排除对shell函数的查找。</span><br><span class="line">-p：如果name在执行&#x27;type -t name&#x27;返回的不是&#x27;file&#x27;，那么什么也不返回；否则会在环境变量PATH中查找并返回可执行文件路径。</span><br><span class="line">-P：即使要查找的name是别名、内建、函数中的一个，仍然会在环境变量PATH中查找并返回可执行文件路径。</span><br><span class="line">-t：根据name的类型返回一个单词（别名，关键字，函数，内建，文件），否则返回空值。</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>当指定的命令可以找到时返回成功，如果有没找到的返回失败。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>接下来要用到的例子假设’~&#x2F;.bashrc’文件定义了以下的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">mybash()&#123; vim ~/.bashrc; &#125;</span><br></pre></td></tr></table></figure>
<p>而且执行环境里没有使用enable禁用内建命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">mybash is a function</span><br><span class="line">mybash ()</span><br><span class="line">&#123;</span><br><span class="line">    vim ~/.bashrc</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a -f mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出（因为排除了函数，所以报错）</span></span><br><span class="line">bash: type: mybash: not found</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a -p mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出为空（因为排除了函数，所以什么也不返回）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">ls is aliased to `ls --color=suto&#x27;</span><br><span class="line">ls is /usr/bin/ls</span><br><span class="line">ls is /bin/ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -a -p <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">/usr/bin/ls</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;-f&#x27;</span>不会影响<span class="string">&#x27;-P&#x27;</span>的范围，<span class="string">&#x27;-f&#x27;</span>不建议和<span class="string">&#x27;-p&#x27;</span>使用。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：<span class="built_in">printf</span>同时是内建命令以及可执行文件（GNU coreutils），优先作为内建处理。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -p <span class="built_in">printf</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出为空</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -P <span class="built_in">printf</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">/usr/bin/printf</span><br><span class="line">/bin/printf</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有多个类型，那么输出优先级最高的类型。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">alias</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t <span class="keyword">for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出（bash关键字）</span></span><br><span class="line">keyword</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">function</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t -f mybash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出空值</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t <span class="built_in">printf</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出（bash内建优先级高）</span></span><br><span class="line">builtin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">type</span> -t <span class="built_in">chmod</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">file</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>该命令是bash内建命令，相关的帮助信息请查看<code>help</code>命令。</li>
<li>命令优先级问题请查看<code>builtin</code>命令。</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>trap捕获信号</title>
    <url>/posts/50609df4/</url>
    <content><![CDATA[<h1 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h1><p>捕捉信号和其他事件并执行命令。</p>
<span id="more"></span>

<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trap [-lp] [[arg] signal_spec ...]</span><br></pre></td></tr></table></figure>

<h2 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h2><ul>
<li>用于指定在接收到信号后将要采取的动作。</li>
<li>脚本程序被中断时执行清理工作。</li>
</ul>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-l    打印信号名称以及信号名称对应的数字。</span><br><span class="line">-p    显示与每个信号关联的trap命令。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arg：接收到信号时执行的命令。</span><br><span class="line">signal_spec：信号名称或信号名称对应的数字。</span><br></pre></td></tr></table></figure>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>如果表达式执行结果为成功时返回0，当参数 <code>signal_spec</code> 没有指定有效值时返回1。</p>
<h2 id="关于信号"><a href="#关于信号" class="headerlink" title="关于信号"></a>关于信号</h2><p>信号是一种进程间通信机制，它给应用程序提供一种异步的软件中断，使应用程序有机会接受其他程序活终端发送的命令(即信号)。应用程序收到信号后，有三种处理方式：忽略，默认，或捕捉。进程收到一个信号后，会检查对该信号的处理机制。如果是SIG_IGN，就忽略该信号；如果是SIG_DFT，则会采用系统默认的处理动作，通常是终止进程或忽略该信号；如果给该信号指定了一个处理函数(捕捉)，则会中断当前进程正在执行的任务，转而去执行该信号的处理函数，返回后再继续执行被中断的任务。</p>
<p>在有些情况下，我们不希望自己的shell脚本在运行时刻被中断，比如说我们写得shell脚本设为某一用户的默认shell，使这一用户进入系统后只能作某一项工作，如数据库备份， 我们可不希望用户使用 Ctrl+C 等方法进入到shell状态做我们不希望做的事情。这便用到了信号处理。</p>
<p>以下是一些你可能会遇到的常见信号：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>信号数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIGHUP</td>
<td>1</td>
<td>本信号在用户终端连接（正常或非正常）结束时发出，通常是在终端的控制进程结束时，通知同一session内的各个作业，这时它们与控制终端不再关联。登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>程序终止(interrupt)信号，在用户键入 Ctrl+C 时发出。</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>和SIGINT类似，但由QUIT字符(通常是Ctrl+\)来控制。进程在因收到SIGQUIT退出时会产生core文件，在这个意义上类似于一个程序错误信号。</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术错误。</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>用来立即结束程序的运行。本信号不能被阻塞，处理和忽略。</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号。</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理. 通常用来要求程序自己正常退出；kill 命令缺省产生这个信号。</td>
</tr>
</tbody></table>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>当shell收到 <code>HUP INT PIPE QUIT TERM</code> 这几个命令时，当前执行的程序会执行 <code>exit 1</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@pc root]$ trap &quot;exit 1&quot; HUP INT PIPE QUIT TERM</span><br></pre></td></tr></table></figure>

<h3 id="1-清理临时文件"><a href="#1-清理临时文件" class="headerlink" title="1 清理临时文件"></a>1 清理临时文件</h3><p>下面展示了如果有人试图从终端中止程序时，如何删除文件然后退出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trap &quot;rm -f $WORKDIR/work1 $WORKDIR/dataout; exit&quot; 2</span><br></pre></td></tr></table></figure>

<p>执行shell程序，如果程序接收信号为2，那么这两个文件 （work1 和 dataout） 将被自动删除。</p>
<p>添加信号1 <code>SIGHUP</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> <span class="string">&quot;rm -f <span class="variable">$WORKDIR</span>/work1 <span class="variable">$WORKDIR</span>/dataout; exit&quot;</span> 1 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-忽略信号"><a href="#2-忽略信号" class="headerlink" title="2 忽略信号"></a>2 忽略信号</h3><p>如果陷阱列出的命令是空的，指定的信号接收时，将被忽略：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> <span class="string">&#x27;&#x27;</span> 2</span></span><br></pre></td></tr></table></figure>

<p>忽略多个信号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> <span class="string">&#x27;&#x27;</span> 1 2 3 15</span></span><br></pre></td></tr></table></figure>


<h3 id="3-重置陷阱"><a href="#3-重置陷阱" class="headerlink" title="3 重置陷阱"></a>3 重置陷阱</h3><p>当你改变了收到信号后采取的动作，你可以省略第一个参数来重置到默认行为。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> 1 2</span></span><br></pre></td></tr></table></figure>


<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li><code>trap -l</code> 等价于执行 <code>kill -l</code>。</li>
<li>发送信号请查看 <code>kill</code> 命令。</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写一个shell脚本</title>
    <url>/posts/5b59793/</url>
    <content><![CDATA[<h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><p>用户事先编写一个 sh 脚本文件，内含 shell 脚本，而后使用 shell 程序执行该脚本，这种方式，我们习惯称为 shell 编程。</p>
<p>shell 脚本中包含一些编程元素：</p>
<ul>
<li>if…else 选择结构，case…in 开关语句，for、while、until 循环；</li>
<li>变量、数组、字符串、注释、加减乘除、逻辑运算等概念；</li>
<li>函数，包括用户自定义的函数和内置函数</li>
</ul>
<span id="more"></span>
<h1 id="脚本的参数"><a href="#脚本的参数" class="headerlink" title="脚本的参数"></a>脚本的参数</h1><p>运行脚本，可以添加参数。这些参数在脚本文件内部可以使用 <code>$n</code> 的形式来接收。例如，<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td align="left">脚本名</td>
</tr>
<tr>
<td align="left">$n</td>
<td align="left">位置参数</td>
</tr>
<tr>
<td align="left">$#</td>
<td align="left">传递给脚本的参数个数</td>
</tr>
<tr>
<td align="left">$*</td>
<td align="left">传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td align="left">$@</td>
<td align="left">传递给脚本或函数的所有参数。当被双引号包含时，与上面稍有不同</td>
</tr>
</tbody></table>
<h3 id="和-的差别"><a href="#和-的差别" class="headerlink" title="$*和$@的差别"></a>$*和$@的差别</h3><p>$*和 $@ 都表示传递给函数或脚本的所有参数。<br>但是当它们被双引号” “包含时，就会有区别了：</p>
<ul>
<li>“$*”会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。</li>
<li>“$@”仍然将每个参数都看作一份数据，彼此之间是独立的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;print each param from \&quot;\$*\&quot;&quot;</span><br><span class="line">for var in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;$var&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;print each param from \&quot;\$@\&quot;&quot;</span><br><span class="line">for var in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;$var&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">$ ./test.sh a b c d</span><br><span class="line">print each param from &quot;$*&quot;</span><br><span class="line">a b c d</span><br><span class="line">print each param from &quot;$@&quot;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p>对于$*，只循环了 1 次，因为它只有 1 份数据；<br>对于$@，循环了 5 次，因为它有 5 份数据</p>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>我们可以检查对参数个数进行检查，如果脚本的参数个数不达标则报错退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $# -ne 2 ];then</span><br><span class="line">   echo &quot;error:****&quot;</span><br><span class="line">   exit -1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>也可以用可选参数方式对部分变量赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TAG=default-tag</span><br><span class="line">BRANCH=default-branch</span><br><span class="line">REPO=default-repo</span><br><span class="line"></span><br><span class="line">while [ &quot;$1&quot; != &quot;&quot; ]; do</span><br><span class="line">  case $1 in</span><br><span class="line">    -r)</span><br><span class="line">      shift</span><br><span class="line">      REPO=$1</span><br><span class="line">      ;;</span><br><span class="line">    -b)</span><br><span class="line">      shift</span><br><span class="line">      BRANCH=$1</span><br><span class="line">      ;;</span><br><span class="line">    -t)</span><br><span class="line">      shift</span><br><span class="line">      TAG=$1</span><br><span class="line">      ;;</span><br><span class="line">    *)</span><br><span class="line">      echo &gt;&amp;2 &quot;Usage2: $0 -r [value] -b [value] -t [value]&quot;</span><br><span class="line">      exit 1</span><br><span class="line">      ;;</span><br><span class="line">  esac</span><br><span class="line">  shift</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $TAG</span><br><span class="line">echo $BRANCH</span><br><span class="line">echo $REPO</span><br></pre></td></tr></table></figure>
<p>此处，<code>shift</code>命令用于向左移动脚本的参数位置。每次调用<code>shift</code>命令，脚本的参数位置都会向左移动一个位置，原来的 <code>$2</code> 变成<code>$1</code>，<code>$3</code>变成<code>$2</code>，依此类推。这在处理脚本的命令行参数时特别有用</p>
<h1 id="设置shell特性"><a href="#设置shell特性" class="headerlink" title="设置shell特性"></a>设置shell特性</h1><p>用set命令设置shell的特性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -x</span><br></pre></td></tr></table></figure>
<h3 id="e-表示shell脚本有错误立刻退出"><a href="#e-表示shell脚本有错误立刻退出" class="headerlink" title="-e 表示shell脚本有错误立刻退出"></a>-e 表示shell脚本有错误立刻退出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -e</span><br><span class="line">cd aaa</span><br><span class="line">ls</span><br><span class="line">echo &quot;end&quot;</span><br></pre></td></tr></table></figure>
<p>此处没有aaa目录，shell脚本会终止在第三行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/test.sh: line 3: cd: aaa: No such file or directory</span><br></pre></td></tr></table></figure>

<h3 id="u-表示shell会将unset的，或者为空的变量视为错误并退出"><a href="#u-表示shell会将unset的，或者为空的变量视为错误并退出" class="headerlink" title="-u 表示shell会将unset的，或者为空的变量视为错误并退出"></a>-u 表示shell会将unset的，或者为空的变量视为错误并退出</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -u</span><br><span class="line">echo $PATH</span><br><span class="line">echo $TOKEN     # ./test.sh: line 4: TOKEN: unbound variable</span><br><span class="line">ls</span><br><span class="line">echo &quot;end&quot;</span><br></pre></td></tr></table></figure>

<h3 id="x-表示调试模式，执行的每一命令都打印上"><a href="#x-表示调试模式，执行的每一命令都打印上" class="headerlink" title="-x 表示调试模式，执行的每一命令都打印上"></a>-x 表示调试模式，执行的每一命令都打印上</h3><h1 id="脚本函数"><a href="#脚本函数" class="headerlink" title="脚本函数"></a>脚本函数</h1><p>在Shell脚本中，可以使用function关键字来定义函数。以下是一个简单的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say_hello() &#123;</span><br><span class="line">    echo &quot;Hello, world!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">say_hello</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了一个名为say_hello的函数，函数体中使用echo语句输出字符串Hello, world!。在函数定义后，使用函数名来调用函数，例如say_hello。</p>
<p>如果函数需要传递参数，则可以在函数名后面添加参数列表。以下是一个带参数的函数示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say_hello_to() &#123;</span><br><span class="line">    echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">say_hello_to &quot;John&quot;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了一个名为say_hello_to的函数，并在函数名后面添加了参数列表。函数体中使用echo语句输出字符串Hello, <code>$1</code>!，其中$1表示第一个参数的值。在函数调用时，将要传递的参数作为参数列表的值传递给函数，例如say_hello_to “John”。</p>
<p>除了使用function关键字来定义函数之外，还可以使用函数简写语法来定义函数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">say_hello() &#123;</span><br><span class="line">    echo &quot;Hello, world!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">say_hello</span><br></pre></td></tr></table></figure>

<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>在Shell脚本中，可以使用return语句来返回函数的值。以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    local sum=$(($1 + $2))</span><br><span class="line">    return $sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数并获取返回值</span><br><span class="line">add 10 20</span><br><span class="line">result=$?</span><br><span class="line"></span><br><span class="line">echo &quot;The sum is: $result&quot;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了一个名为add的函数，函数体中计算两个参数的和并将结果保存在变量sum中。使用return语句将变量sum的值作为函数返回值。在函数调用时，将要传递的参数作为参数列表的值传递给函数，例如add 10 20。使用$?来获取函数的返回值，将其保存在变量result中，并使用echo语句输出返回值。</p>
<p>注意，在Shell脚本中，函数的返回值只能是一个整数值。如果需要返回其他类型的值（如字符串），可以将其保存在一个变量中，并在函数结束时输出该变量的值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function get_greeting() &#123;</span><br><span class="line">    local name=$1</span><br><span class="line">    local greeting=&quot;Hello, $name!&quot;</span><br><span class="line">    echo $greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数并获取返回值</span><br><span class="line">result=$(get_greeting &quot;John&quot;)</span><br><span class="line">echo $result</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，定义了一个名为get_greeting的函数，函数体中使用参数name构建问候语，并将其保存在变量greeting中。在函数结束时，使用echo语句输出变量greeting的值。在函数调用时，将要传递的参数作为参数列表的值传递给函数，例如get_greeting “John”。将函数的输出保存在变量result中，并使用echo语句输出返回值。</p>
<h1 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h1><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td><code>**</code></td>
<td>求幂</td>
</tr>
<tr>
<td><code>%</code></td>
<td>求模</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加等(plus-equal) 把原变量值增加一个常量并重新赋值给变量</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减等(minus-equal) 把原变量值减少一个常量并重新赋值给变量</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘等(times-equal) 把原变量值乘上一个常量并重新赋值给变量</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除等(slash-equal) 把原变量值除以一个常量并重新赋值给变量</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模等(mod-equal) 把原变量值除以一个常量整除（即取模）并重新赋余数的值给变量</td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bash在版本2.02引入了<span class="string">&quot;**&quot;</span>求幂操作符.</span></span><br><span class="line">let &quot;z=5**3&quot;</span><br><span class="line">echo &quot;z = $z&quot;   # z = 125</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">求模（它返回整数整除一个数后的余数）</span></span><br><span class="line">let &quot;y=5 % 3&quot;</span><br><span class="line">echo &quot;y = $y&quot;   # y = 2</span><br><span class="line"></span><br><span class="line">let &quot;var += 5&quot; # 会使变量var值加了5并把值赋给var.</span><br><span class="line">let &quot;var *= 4&quot; # 使变量var的值乘上4并把值赋给var.</span><br></pre></td></tr></table></figure>

<h2 id="双括号结构"><a href="#双括号结构" class="headerlink" title="双括号结构"></a>双括号结构</h2><p>用<code>((...))</code>结构来处理变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(( a = 23 ))  # 以C风格来设置一个值，在&quot;=&quot;两边可以有空格.</span><br><span class="line">echo &quot;a (initial value) = $a&quot;</span><br><span class="line"></span><br><span class="line">(( a++ ))     # C风格的计算后自增.</span><br><span class="line">echo &quot;a (after a++) = $a&quot;</span><br><span class="line"></span><br><span class="line">(( a-- ))     # C风格的计算后自减.</span><br><span class="line">echo &quot;a (after a--) = $a&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(( ++a ))     # C风格的计算前自增.</span><br><span class="line">echo &quot;a (after ++a) = $a&quot;</span><br><span class="line"></span><br><span class="line">(( --a ))     # C风格的计算前自减.</span><br><span class="line">echo &quot;a (after --a) = $a&quot;</span><br></pre></td></tr></table></figure>
<p>算术运算符必须用双括号(( ))括起来，以便Shell可以正确地解析表达式</p>
<h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>在 sh&#x2F;bash 里，<strong>如果 else 分支没有语句执行，就不要写这个 else</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==========if============</span><br><span class="line">if condition;then</span><br><span class="line">  command</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========if-else=========</span><br><span class="line">if condition;then</span><br><span class="line">  command</span><br><span class="line">else</span><br><span class="line">  command</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=====if-elif-else=======</span><br><span class="line">if condition;then</span><br><span class="line">  command</span><br><span class="line">elif condition;then</span><br><span class="line">  command</span><br><span class="line">else</span><br><span class="line">  command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h2><p>如果下面的条件成立返回真</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>文件存在</td>
</tr>
<tr>
<td>-f</td>
<td>文件是一个普通文件(不是一个目录或是一个设备文件)</td>
</tr>
<tr>
<td>-d</td>
<td>文件是一个目录</td>
</tr>
<tr>
<td>-b</td>
<td>文件是一个块设备(软盘，光驱，等等。)</td>
</tr>
<tr>
<td>-c</td>
<td>文件是一个字符设备(键盘，调制解调器，声卡，等等。)</td>
</tr>
<tr>
<td>-p</td>
<td>文件是一个管道</td>
</tr>
<tr>
<td>-h</td>
<td>文件是一个符号链接</td>
</tr>
<tr>
<td>-L</td>
<td>文件是一个符号链接</td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ ! -f &quot;/data/filename&quot; ];then</span><br><span class="line">   echo &quot;文件不存在&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件存在&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">或者:</span><br><span class="line">FILE=/etc/resolv.conf</span><br><span class="line">if test -f &quot;$FILE&quot;; then</span><br><span class="line">    echo &quot;$FILE exist&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">另外,还有一种方式:</span><br><span class="line">[ -e config.json ] &amp;&amp; echo &quot;Info: Required config.json file is available. &quot; || &#123;</span><br><span class="line">  echo &quot;Error: Missing config.json file.&quot;</span><br><span class="line">  exit 9999</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-f FILE - 判断文件是否存在</span><br><span class="line">-b FILE - 如果文件存在并且是块特殊文件，则为True。</span><br><span class="line">-c FILE - 如果文件存在并且是特殊字符文件，则为True。</span><br><span class="line">-d FILE - 如果文件存在并且是目录，则为True。</span><br></pre></td></tr></table></figure>

<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>二元比较操作符比较两个变量或是数值。注意整数和字符串比较的分别。</p>
<h3 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h3><table>
<thead>
<tr>
<th>比较操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>-eq</code></td>
<td>等于</td>
<td><code>if [ &quot;$a&quot; -eq &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>不等于</td>
<td><code>if [ &quot;$a&quot; -ne &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>大于</td>
<td><code>if [ &quot;$a&quot; -gt &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>大于等于</td>
<td><code>if [ &quot;$a&quot; -ge &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>小于</td>
<td><code>if [ &quot;$a&quot; -lt &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>-le</code></td>
<td>小于等于</td>
<td><code>if [ &quot;$a&quot; -le &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于(在双括号里使用)</td>
<td><code>((&quot;$a&quot; &lt; &quot;$b&quot;))</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于 (在双括号里使用)</td>
<td><code>((&quot;$a&quot; &lt;= &quot;$b&quot;))</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于 (在双括号里使用)</td>
<td><code>((&quot;$a&quot; &gt; &quot;$b&quot;))</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于(在双括号里使用)</td>
<td><code>((&quot;$a&quot; &gt;= &quot;$b&quot;))</code></td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">-eq:等于</span><br><span class="line">-ne:不等于</span><br><span class="line">-gt:大于</span><br><span class="line">-lt:小于</span><br><span class="line">-ge:大于等于</span><br><span class="line">-le:小于等于</span><br></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><table>
<thead>
<tr>
<th>比较操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>等于</td>
<td><code>if [ &quot;$a&quot; = &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于，它和&#x3D;是同义词。</td>
<td><code>if [ &quot;$a&quot; == &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不相等，操作符在[[ … ]]结构里使用模式匹配.</td>
<td><code>if [ &quot;$a&quot; != &quot;$b&quot; ]</code></td>
</tr>
<tr>
<td>-z</td>
<td>字符串为”null”，即是指字符串长度为零。</td>
<td>-</td>
</tr>
<tr>
<td>-n</td>
<td>字符串不为”null”，即长度不为零。</td>
<td>-</td>
</tr>
</tbody></table>
<p>比如，判断变量是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过-n判断</span><br><span class="line">if [ -n &quot;$var&quot; ];then</span><br><span class="line">   echo &quot;var exist&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;var not exist&quot;</span><br><span class="line">fi</span><br><span class="line">其中 &quot;&quot; 必不可缺少</span><br></pre></td></tr></table></figure>
<p>此外，在 Shell 中，[[ ]] 是 Shell 的内置命令，用于检测某个条件是否成立。同时，它支持正则表达式，可以使用&#x3D;~来检测字符串是否符合某个正则表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [[ $APK == *release*.apk ]]; then</span><br><span class="line">    # 测试apk是否满足这样的格式</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="逻辑比较"><a href="#逻辑比较" class="headerlink" title="逻辑比较"></a>逻辑比较</h3><table>
<thead>
<tr>
<th>比较操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>逻辑与，如果exp1和exp2都为真，则exp1 -a exp2返回真。</td>
<td><code>if [ &quot;$exp1&quot; -a &quot;$exp2&quot; ]</code></td>
</tr>
<tr>
<td>-o</td>
<td>逻辑或，只要exp1和exp2任何一个为真，则exp1 -o exp2 返回真。</td>
<td><code>if [ &quot;$exp1&quot; -o &quot;$exp2&quot; ]</code></td>
</tr>
</tbody></table>
<p>也可以用这种方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1||command2</span><br><span class="line">只有当command1不正确执行才执行command2</span><br><span class="line">if [[ $suffix == *.apk ]] || [[ $suffix == *.zip ]]; then</span><br><span class="line">    # 后缀是apk或者zip</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [[ &quot;$local_branch&quot; = &quot;origin/release&quot;* ]] || [[ &quot;$local_branch&quot; = &quot;origin/internal&quot;* ]];then</span><br><span class="line">      </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="命令的静默输出"><a href="#命令的静默输出" class="headerlink" title="命令的静默输出"></a>命令的静默输出</h3><p>有些命令可以用来判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找某个分支是否存在，如果存在就删除</span><br><span class="line">if git show-ref --verify --quiet refs/heads/$2; then</span><br><span class="line">   git branch -D $2;</span><br><span class="line">fi</span><br><span class="line">  </span><br><span class="line">grep -q &quot;test&quot; filename</span><br><span class="line"># 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span><br><span class="line"></span><br><span class="line">if grep -q &#x27;test&#x27; filename;then</span><br><span class="line">  echo &quot;find test&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>判断上一条命令是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff a.txt b.txt   #diff文件有差别时，命令的返回结果不为0</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">   echo &quot;文件比较有差别&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto</span><br><span class="line">do</span><br><span class="line">  echo $planet  # 每个行星被单独打印在一行上.</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>以命令的返回结果作为list来进行循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIRS=$(ls -l|sed &#x27;1d&#x27;|awk &#x27;&#123;print $9&#125;&#x27;)</span><br><span class="line"># 此处要删除第一行，因为第一行是total </span><br><span class="line">for dir in $&#123;DIRS[*]&#125;</span><br><span class="line">do</span><br><span class="line">   echo $dir</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>数字循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#有一组urls,按照;分割后</span><br><span class="line">for url in $(echo &quot;$urls&quot; | awk -F&#x27;;&#x27; &#x27;&#123;for(i=1;i&lt;=NF;i++) print $i&#125;&#x27;); do</span><br><span class="line">  curl &quot;$url&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#使用seq命令生成数字序列</span><br><span class="line">for i in $(seq 1 5)</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">   statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">num=0</span><br><span class="line">while ((num &lt; 3))</span><br><span class="line">do</span><br><span class="line">	echo $num</span><br><span class="line">	((num++))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">var0=0</span><br><span class="line">LIMIT=10</span><br><span class="line"></span><br><span class="line">while [ &quot;$var0&quot; -lt &quot;$LIMIT&quot; ]</span><br><span class="line">do</span><br><span class="line">  echo -n &quot;$var0 &quot;        # -n 将会阻止产生新行。</span><br><span class="line">  #             ^           空格,数字之间的分隔。</span><br><span class="line">  var0=`expr $var0 + 1`   # var0=$(($var0+1))  也可以。</span><br><span class="line">                          # var0=$((var0 + 1)) 也可以。</span><br><span class="line">                          # let &quot;var0 += 1&quot;    也可以。</span><br><span class="line">done                      # 使用其他的方法也行。</span><br></pre></td></tr></table></figure>
<p>读文件的每一行直到末尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    # do something to each line</span><br><span class="line">done &lt; file</span><br></pre></td></tr></table></figure>

<h2 id="case-…-esac"><a href="#case-…-esac" class="headerlink" title="case … esac"></a>case … esac</h2><p>类似switch case</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case 变量 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>示例:  输入 1 到 4 之间的数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read Num</span><br><span class="line">case $Num in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>三剑客grep,sed和awk</title>
    <url>/posts/e2f332a0/</url>
    <content><![CDATA[<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤&#x2F;搜索的特定字符</p>
<span id="more"></span>
<h2 id="grep命令常见用法"><a href="#grep命令常见用法" class="headerlink" title="grep命令常见用法"></a>grep命令常见用法</h2><p>在文件中搜索一个单词，命令会返回一个包含 <strong>“match_pattern”</strong> 的文本行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep match_pattern file_name</span><br><span class="line">grep &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c --count    # 计算符合范本样式的列数。</span><br><span class="line">-A &lt;显示行数&gt;   --after-context=&lt;显示行数&gt; # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span><br><span class="line">-B&lt;显示行数&gt;   --before-context=&lt;显示行数&gt;   # 除了显示符合样式的那一行之外，并显示该行之前的内容。</span><br><span class="line">-C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span><br><span class="line">-q --quiet或--silent     # 不显示任何信息。</span><br><span class="line">-v --revert-match # 反转查找。</span><br><span class="line">-o # 只输出文件中匹配到的部分。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在多个文件中查找：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;match_pattern&quot; file_1 file_2 file_3 ...</span><br></pre></td></tr></table></figure>

<p>输出除之外的所有行  <strong>-v</strong>  选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -v &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure>

<p>只输出文件中匹配到的部分  <strong>-o</strong>  选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is a test line. | grep -o -E &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line">echo this is a test line. | egrep -o &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br></pre></td></tr></table></figure>

<p>统计文件或者文本中包含匹配字符串的行数  <strong>-c</strong>  选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -c &quot;text&quot; file_name</span><br></pre></td></tr></table></figure>

<p>输出包含匹配字符串的行数  <strong>-n</strong>  选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;text&quot; -n file_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">cat file_name | grep &quot;text&quot; -n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多个文件</span></span><br><span class="line">grep &quot;text&quot; -n file_1 file_2</span><br></pre></td></tr></table></figure>

<p>在多级目录中对文本进行递归搜索：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;text&quot; . -r -n</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.表示当前目录。</span></span><br></pre></td></tr></table></figure>

<p>选项  <strong>-e</strong>  制动多个匹配样式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -o</span><br><span class="line">is</span><br><span class="line">is</span><br><span class="line">line</span><br></pre></td></tr></table></figure>

<p>在grep搜索结果中包括或者排除指定文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只在目录中所有的.php和.html文件中递归搜索字符<span class="string">&quot;main()&quot;</span></span></span><br><span class="line">grep &quot;main()&quot; . -r --include *.&#123;php,html&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在搜索结果中排除所有README文件</span></span><br><span class="line">grep &quot;main()&quot; . -r --exclude &quot;README&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在搜索结果中排除filelist文件列表里的文件</span></span><br><span class="line">grep &quot;main()&quot; . -r --exclude-from filelist</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>grep静默输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -q &quot;test&quot; filename</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span></span><br><span class="line"></span><br><span class="line">if grep -q &#x27;test&#x27; filename;then</span><br><span class="line">  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>打印出匹配文本之前或者之后的行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示匹配某个结果之后的3行，使用 -A 选项：</span></span><br><span class="line">seq 10 | grep &quot;5&quot; -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示匹配某个结果之前的3行，使用 -B 选项：</span></span><br><span class="line">seq 10 | grep &quot;5&quot; -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示匹配某个结果的前三行和后三行，使用 -C 选项：</span></span><br><span class="line">seq 10 | grep &quot;5&quot; -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：</span></span><br><span class="line">echo -e &quot;a\nb\nc\na\nb\nc&quot; | grep a -A 1</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p><strong>sed</strong> 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<p> <strong>命令格式</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed [options] &#x27;command&#x27; file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure>
<h2 id="sed用法实例"><a href="#sed用法实例" class="headerlink" title="sed用法实例"></a>sed用法实例</h2><h3 id="打印奇数行或偶数行"><a href="#打印奇数行或偶数行" class="headerlink" title="打印奇数行或偶数行"></a>打印奇数行或偶数行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;1~2p&#x27; test.txt  #奇数行</span><br><span class="line">sed -n &#x27;2~2p&#x27; test.txt  #偶数行</span><br></pre></td></tr></table></figure>

<h3 id="替换操作：s命令"><a href="#替换操作：s命令" class="headerlink" title="替换操作：s命令"></a>替换操作：s命令</h3><p>替换文本中的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/book/books/&#x27; file</span><br></pre></td></tr></table></figure>

<p> <strong>-n选项</strong> 和 <strong>p命令</strong> 一起使用表示只打印那些发生替换的行：</p>
<p>sed -n ‘s&#x2F;test&#x2F;TEST&#x2F;p’ file</p>
<p>直接编辑文件 <strong>选项-i</strong> ，会匹配file文件中每一行的所有book替换为books：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/book/books/g&#x27; file</span><br></pre></td></tr></table></figure>

<h3 id="全面替换标记g"><a href="#全面替换标记g" class="headerlink" title="全面替换标记g"></a>全面替换标记g</h3><p>使用后缀 &#x2F;g 标记会替换每一行中的所有匹配：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/book/books/g&#x27; file</span><br></pre></td></tr></table></figure>

<p>当需要从第N处匹配开始替换时，可以使用 &#x2F;Ng：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/2g&#x27;</span><br><span class="line">skSKSKSKSKSK</span><br><span class="line"></span><br><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/3g&#x27;</span><br><span class="line">skskSKSKSKSK</span><br><span class="line"></span><br><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/4g&#x27;</span><br><span class="line">skskskSKSKSK</span><br></pre></td></tr></table></figure>

<h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h3><p>以上命令中字符 &#x2F; 在sed中作为定界符使用，也可以使用任意的定界符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s:test:TEXT:g&#x27;</span><br><span class="line">sed &#x27;s|test|TEXT|g&#x27;</span><br></pre></td></tr></table></figure>

<p>定界符出现在样式内部时，需要进行转义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/\/bin/\/usr\/local\/bin/g&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="删除操作：d命令"><a href="#删除操作：d命令" class="headerlink" title="删除操作：d命令"></a>删除操作：d命令</h3><p>删除空白行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^$/d&#x27; file</span><br></pre></td></tr></table></figure>
<p>删除文件的第2行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;2d&#x27; file</span><br><span class="line">sed &#x27;2d;5d&#x27; file</span><br></pre></td></tr></table></figure>
<p>删除文件的第2行到末尾所有行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;2,$d&#x27; file</span><br></pre></td></tr></table></figure>
<p>删除文件最后一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;$d&#x27; file</span><br></pre></td></tr></table></figure>
<p>删除文件中所有开头是test的行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^test/&#x27;d file</span><br></pre></td></tr></table></figure>
<h3 id="已匹配字符串标记"><a href="#已匹配字符串标记" class="headerlink" title="已匹配字符串标记&amp;"></a>已匹配字符串标记&amp;</h3><p>正则表达式 \w+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is a test line | sed &#x27;s/\w\+/[&amp;]/g&#x27;</span><br><span class="line">[this] [is] [a] [test] [line]</span><br></pre></td></tr></table></figure>

<p>所有以192.168.0.1开头的行都会被替换成它自已加localhost：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/^192.168.0.1/&amp;localhost/&#x27; file</span><br><span class="line">192.168.0.1localhost</span><br></pre></td></tr></table></figure>

<h3 id="子串匹配标记-1"><a href="#子串匹配标记-1" class="headerlink" title="子串匹配标记\1"></a>子串匹配标记\1</h3><p>匹配给定样式的其中一部分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is digit 7 in a number | sed &#x27;s/digit \([0-9]\)/\1/&#x27;</span><br><span class="line">this is 7 in a number</span><br></pre></td></tr></table></figure>

<p>命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，(..) 用于匹配子串，对于匹配到的第一个子串就标记为  <strong>\1</strong> ，依此类推匹配到的第二个结果就是  <strong>\2</strong> ，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo aaa BBB | sed &#x27;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#x27;</span><br><span class="line">BBB aaa</span><br></pre></td></tr></table></figure>

<p>love被标记为1，所有loveable会被替换成lovers，并打印出来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;s/\(love\)able/\1rs/p&#x27; file</span><br></pre></td></tr></table></figure>

<p>通过替换获取ip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig ens32 | sed -n &#x27;/inet /p&#x27; | sed &#x27;s/inet \([0-9.]\+\).*/\1/&#x27;</span><br><span class="line">192.168.75.126</span><br></pre></td></tr></table></figure>
<h3 id="大小写转换U-L"><a href="#大小写转换U-L" class="headerlink" title="大小写转换U&#x2F;L"></a>大小写转换U&#x2F;L</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\u：	首字母转换为大写</span><br><span class="line">\U：  全部转换为大写</span><br><span class="line">\l：	 首字母转换为小写</span><br><span class="line">\L：	 全部转换为小写</span><br></pre></td></tr></table></figure>

<p>首字母转换为大写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]# sed &#x27;s/^[a-z]\+/\u&amp;/&#x27; passwd </span><br><span class="line">Root:x:0:0:root:/root:/bin/bash</span><br><span class="line">Bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">Daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">Adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">Lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">Sync:x:5:0:sync:/sbin:/bin/sync</span><br></pre></td></tr></table></figure>

<p>匹配到的字符全部转换为大写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]# sed &#x27;s/^[a-z]\+/\U&amp;/&#x27; passwd </span><br><span class="line">ROOT:x:0:0:root:/root:/bin/bash</span><br><span class="line">BIN:x:1:1:bin:/bin:/sbin/nologin</span><br></pre></td></tr></table></figure>

<h3 id="组合多个表达式"><a href="#组合多个表达式" class="headerlink" title="组合多个表达式"></a>组合多个表达式</h3><ol>
<li>替换文本中的多个字符串：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;s/old_string/new_string/g&#x27; -e &#x27;s/another_old_string/another_new_string/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除文本中的多个行：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;1d&#x27; -e &#x27;/pattern/d&#x27; file.txt</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在文本中插入多个行：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;1i\inserted_line1&#x27; -e &#x27;2i\inserted_line2&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>其中，-e 表示指定一个表达式，多个表达式之间用 -e 分隔。每个表达式可以是一个 sed 命令，例如 s、d、i 等。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test=hello</span><br><span class="line">echo hello WORLD | sed &quot;s/$test/HELLO&quot;</span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h3 id="选定行的范围：-（逗号）"><a href="#选定行的范围：-（逗号）" class="headerlink" title="选定行的范围：,（逗号）"></a>选定行的范围：,（逗号）</h3><p>所有在模板test和check所确定的范围内的行都被打印：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/test/,/check/p&#x27; file</span><br></pre></td></tr></table></figure>

<p>打印从第5行开始到第一个包含以test开始的行之间的所有行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;5,/^test/p&#x27; file</span><br></pre></td></tr></table></figure>

<p>对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/test/,/west/s/$/aaa bbb/&#x27; file</span><br></pre></td></tr></table></figure>

<h3 id="多点编辑：e命令"><a href="#多点编辑：e命令" class="headerlink" title="多点编辑：e命令"></a>多点编辑：e命令</h3><p>-e选项允许在同一行里执行多条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;1,5d&#x27; -e &#x27;s/test/check/&#x27; file</span><br><span class="line"></span><br><span class="line">echo &quot;hello, world &quot; | cut -d&#x27;,&#x27; -f2 | sed -e &#x27;s/^[[:space:]]*//&#x27; -e &#x27;s/[[:space:]]*$//&#x27;</span><br><span class="line">去除单词前面跟后面的空格</span><br><span class="line"></span><br><span class="line">echo &quot; key = value &quot;|cut -d &#x27;=&#x27; -f 2|sed -e &#x27;s/^[[:space:]]*//&#x27; -e &#x27;s/[[:space:]]*$//&#x27;</span><br></pre></td></tr></table></figure>

<p>上面sed表达式的第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</p>
<h3 id="追加（行下）：a-命令"><a href="#追加（行下）：a-命令" class="headerlink" title="追加（行下）：a\命令"></a>追加（行下）：a\命令</h3><p>将 this is a test line 追加到 以test 开头的行后面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^test/a\this is a test line&#x27; file</span><br></pre></td></tr></table></figure>

<p>在 test.conf 文件第2行之后插入 this is a test line：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;2a\this is a test line&#x27; test.conf</span><br></pre></td></tr></table></figure>

<h3 id="插入（行上）：i-命令"><a href="#插入（行上）：i-命令" class="headerlink" title="插入（行上）：i\命令"></a>插入（行上）：i\命令</h3><p>将 this is a test line 追加到以test开头的行前面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^test/i\this is a test line&#x27; file</span><br></pre></td></tr></table></figure>

<p>在test.conf文件第5行之前插入this is a test line：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;5i\this is a test line&#x27; test.conf</span><br></pre></td></tr></table></figure>

<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p><strong>awk</strong> 是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p>
<h2 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h2><p><strong>语法形式</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk [options] &#x27;script&#x27; var=value file(s)</span><br><span class="line">awk [options] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure>

<p><strong>常用命令选项</strong> </p>
<ul>
<li><strong>-F fs</strong> fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:，默认的分隔符是连续的空格或制表符</li>
<li><strong>-v var&#x3D;value</strong> 赋值一个用户定义变量，将外部变量传递给awk</li>
<li><strong>-f scripfile</strong> 从脚本文件中读取awk命令</li>
</ul>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式可以是以下任意一个：</p>
<ul>
<li>&#x2F;正则表达式&#x2F;：使用通配符的扩展集。</li>
<li>关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。</li>
<li>模式匹配表达式：用运算符<code>~</code>（匹配）和<code>!~</code>（不匹配）。</li>
<li>BEGIN语句块、pattern语句块、END语句块：参见awk的工作原理</li>
</ul>
<h2 id="awk脚本基本结构"><a href="#awk脚本基本结构" class="headerlink" title="awk脚本基本结构"></a>awk脚本基本结构</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; print &quot;start&quot; &#125; pattern&#123; commands &#125; END&#123; print &quot;end&quot; &#125;&#x27; file</span><br></pre></td></tr></table></figure>

<p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被 <strong>单引号</strong> 中，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;&#x27; filename</span><br></pre></td></tr></table></figure>

<h3 id="awk的工作原理"><a href="#awk的工作原理" class="headerlink" title="awk的工作原理"></a>awk的工作原理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：执行<code>BEGIN&#123; commands &#125;</code>语句块中的语句；</li>
<li>第二步：从文件或标准输入(stdin)读取一行，然后执行<code>pattern&#123; commands &#125;</code>语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。</li>
<li>第三步：当读至输入流末尾时，执行<code>END&#123; commands &#125;</code>语句块。</li>
</ul>
<p> <strong>BEGIN语句块</strong> 在awk开始从输入流中读取行 <strong>之前</strong> 被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p>
<p> <strong>END语句块</strong> 在awk从输入流中读取完所有的行 <strong>之后</strong> 即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p>
<p> <strong>pattern语句块</strong> 中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行<code>&#123; print &#125;</code>，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p>
<p> <strong>示例</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;A line 1\nA line 2&quot; | awk &#x27;BEGIN&#123; print &quot;Start&quot; &#125; &#123; print &#125; END&#123; print &quot;End&quot; &#125;&#x27;</span><br><span class="line">Start</span><br><span class="line">A line 1</span><br><span class="line">A line 2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>当使用不带参数的<code>print</code>时，它就打印当前行，当<code>print</code>的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo | awk &#x27;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; &#125;&#x27; </span><br><span class="line">v1 v2 v3</span><br></pre></td></tr></table></figure>

<p>双引号拼接使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo | awk &#x27;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; &#125;&#x27;</span><br><span class="line">v1=v2=v3</span><br></pre></td></tr></table></figure>

<p>{ }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i&#x3D;0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。</p>
<h2 id="awk内置变量（预定义变量）"><a href="#awk内置变量（预定义变量）" class="headerlink" title="awk内置变量（预定义变量）"></a>awk内置变量（预定义变量）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">**$n**  当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 </span><br><span class="line">**$0**  这个变量包含执行过程中当前行的文本内容。</span><br><span class="line"></span><br><span class="line">**FILENAME**  当前输入文件的名。</span><br><span class="line">**FS**  字段分隔符（默认是任何空格）。</span><br><span class="line">**NF**  表示字段数，在执行过程中对应于当前的字段数。</span><br><span class="line">**NR**  表示记录数，在执行过程中对应于当前的行号。</span><br><span class="line">**OFMT**  数字的输出格式（默认值是%.6g）。</span><br><span class="line">**OFS**  输出字段分隔符（默认值是一个空格）。</span><br><span class="line">**ORS**  输出记录分隔符（默认值是一个换行符）。</span><br><span class="line">**RS**  记录分隔符（默认是一个换行符）。</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3\nline2 f4 f5\nline3 f6 f7&quot; | awk &#x27;&#123;print &quot;Line No:&quot;NR&quot;, No of fields:&quot;NF, &quot;$0=&quot;$0, &quot;$1=&quot;$1, &quot;$2=&quot;$2, &quot;$3=&quot;$3&#125;&#x27; </span><br><span class="line">Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3</span><br><span class="line">Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5</span><br><span class="line">Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7</span><br></pre></td></tr></table></figure>

<p>使用<code>print $NF</code>可以打印出一行中的最后一个字段，使用<code>$(NF-1)</code>则是打印倒数第二个字段，其他以此类推：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3\n line2 f4 f5&quot; | awk &#x27;&#123;print $NF&#125;&#x27;</span><br><span class="line">f3</span><br><span class="line">f5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3\n line2 f4 f5&quot; | awk &#x27;&#123;print $(NF-1)&#125;&#x27;</span><br><span class="line">f2</span><br><span class="line">f4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印每一行的第二和第三个字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123; print $2,$3 &#125;&#x27; filename</span><br></pre></td></tr></table></figure>

<p>统计文件中的行数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;END&#123; print NR &#125;&#x27; filename</span><br></pre></td></tr></table></figure>

<p>以上命令只使用了END语句块，在读入每一行的时，awk会将NR更新为对应的行号，当到达最后一行NR的值就是最后一行的行号，所以END语句块中的NR就是文件的行数。</p>
<p>一个每一行中第一个字段值累加的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seq 5 | awk &#x27;BEGIN&#123; sum=0; print &quot;总和：&quot; &#125; &#123; print $1&quot;+&quot;; sum+=$1 &#125; END&#123; print &quot;等于&quot;; print sum &#125;&#x27; </span><br><span class="line">总和：</span><br><span class="line">1+</span><br><span class="line">2+</span><br><span class="line">3+</span><br><span class="line">4+</span><br><span class="line">5+</span><br><span class="line">等于</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<h2 id="将外部变量值传递给awk"><a href="#将外部变量值传递给awk" class="headerlink" title="将外部变量值传递给awk"></a>将外部变量值传递给awk</h2><p>借助 <strong><code>-v</code>选项</strong> ，可以将外部值（并非来自stdin）传递给awk：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VAR=10000</span><br><span class="line">echo | awk -v VARIABLE=$VAR &#x27;&#123; print VARIABLE &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>另一种传递外部变量方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var1=&quot;aaa&quot;</span><br><span class="line">var2=&quot;bbb&quot;</span><br><span class="line">echo | awk &#x27;&#123; print v1,v2 &#125;&#x27; v1=$var1 v2=$var2</span><br></pre></td></tr></table></figure>

<p>当输入来自于文件时使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123; print v1,v2 &#125;&#x27; v1=$var1 v2=$var2 filename</span><br></pre></td></tr></table></figure>

<p>以上方法中，变量之间用空格分隔作为awk的命令行参数跟随在BEGIN、{}和END语句块之后。</p>
<h2 id="查找进程pid"><a href="#查找进程pid" class="headerlink" title="查找进程pid"></a>查找进程pid</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -antup | grep 7770 | awk &#x27;&#123; print $NF NR&#125;&#x27; | awk &#x27;&#123; print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/posts/2f57a694/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>正则表达式分为两类</p>
<ul>
<li>基本正则表达式 BRE</li>
<li>扩展正则表达式 ERE</li>
</ul>
<span id="more"></span>
<h2 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^         用于模式最左侧，如&quot;^boy&quot;,匹配以boy单词开头的行</span><br><span class="line">$         用于模式最左侧，如&quot;boy$&quot;,匹配以boy单词结尾的行</span><br><span class="line">^$        匹配空行</span><br><span class="line">\         转义，让特殊含义的字符显示原意</span><br><span class="line">*         匹配前一个字符连续出现0或1次以上</span><br><span class="line">.*        匹配所有内容</span><br><span class="line">^.*       匹配任意多个字符开头的内容</span><br><span class="line">.*$       匹配任意多个字符结尾的内容</span><br><span class="line">[abc]     匹配[]的任意一个字符，a或b或c</span><br><span class="line">[^abc]    与上面相反，非a非b非c的任意字符</span><br><span class="line">\&lt;        如:&#x27;\&lt;grep&#x27;匹配包含以grep开头的单词的行</span><br><span class="line">\&gt;        如:&#x27;grep\&gt;&#x27;匹配包含以grep结尾的单词的行</span><br></pre></td></tr></table></figure>

<h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+         匹配前一个字符 1次或多次</span><br><span class="line">[]+       匹配括号内的字符 1次或多次</span><br><span class="line">?         匹配前一个字符 0次或1次 </span><br><span class="line">|         同时过滤多个字符串</span><br><span class="line">()        被括起来的作为整体</span><br><span class="line">a&#123;n,m&#125;    匹配前一字符，最少n次，最多m次</span><br><span class="line">a&#123;n,&#125;     匹配前一字符，最少n次</span><br><span class="line">a&#123;n&#125;      匹配前一字符正好n次</span><br><span class="line">a&#123;,m&#125;     匹配前一字符，最多m次</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>用Jenkins接口动态修改job的配置</title>
    <url>/posts/8a116419/</url>
    <content><![CDATA[<p>jenkins提供了Rest api接口给我们调用，方便我们来管理jenkins服务器。</p>
<span id="more"></span>

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>首先，需要申请一个有权限的token。这个需要在个人主页中可以创建一个API Token。</p>
<h2 id="Python-Jenkins"><a href="#Python-Jenkins" class="headerlink" title="Python Jenkins"></a>Python Jenkins</h2><p>这是一个对jenkins Rest API接口的包装。具体官网可以看<a href="https://python-jenkins.readthedocs.io/en/latest/">Python-jenkins</a></p>
<p>我们就使用这个python库来完成对jenkins job默认配置的修改</p>
<h3 id="创建jenkins服务"><a href="#创建jenkins服务" class="headerlink" title="创建jenkins服务"></a>创建jenkins服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server=jenkins.Jenkins(jenkins_url,username=&#x27;username&#x27;,password=&quot;token&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="获取一个job的默认配置信息"><a href="#获取一个job的默认配置信息" class="headerlink" title="获取一个job的默认配置信息"></a>获取一个job的默认配置信息</h3><p>他会返回我们一个xml格式的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">job_config_xml = server.get_job_config(My_JOB)</span><br></pre></td></tr></table></figure>
<p>我们可以来修改这个字符串，完成对这个job配置的修改。</p>
<h3 id="修改xml配置"><a href="#修改xml配置" class="headerlink" title="修改xml配置"></a>修改xml配置</h3><p>因为是xml字符串，我们需要使用的<a href="https://docs.python.org/3/library/xml.etree.elementtree.html">ElementTree</a>这个工具来解析这个字符串</p>
<ol>
<li><p>首先通过ET.fromstring，来生成一个包含所有标签的ElementTree对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line">config_xml_root = ET.fromstring(job_config_xml)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后通过root.iter()去查找我们想要的标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config_xml_root.iter(&#x27;hudson.model.StringParameterDefinition&#x27;)</span><br><span class="line">config_xml_root.iter(&#x27;hudson.plugins.validating__string__parameter.ValidatingStringParameterDefinition&#x27;)</span><br></pre></td></tr></table></figure>
<p>比如，我们配置的StringParameter或者ValidatingStringParameter</p>
</li>
<li><p>最后我们去修改指定的默认配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x in cut_branch_config_xml_root.iter(&#x27;hudson.plugins.validating__string__parameter.ValidatingStringParameterDefinition&#x27;):</span><br><span class="line">    item = x.find(&#x27;name&#x27;).text</span><br><span class="line">    if item == &quot;Version&quot;:</span><br><span class="line">       x.find(&#x27;defaultValue&#x27;).text=Version</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后把改好的ET对象转换成xml字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_config_xml = ET.tostring(config_xml_root, encoding=&#x27;unicode&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新配置jenkins job</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.reconfig_job(My_JOB,new_config_xml)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样一个简单的动态修改jenkins job配置的功能就完成了。</p>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>用cut命令来切割字符串</title>
    <url>/posts/9b60227b/</url>
    <content><![CDATA[<h1 id="Cut"><a href="#Cut" class="headerlink" title="Cut"></a>Cut</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut（选项）（参数）</span><br><span class="line"></span><br><span class="line">-b：仅显示行中指定直接范围的内容；</span><br><span class="line">-c：仅显示行中指定范围的字符；</span><br><span class="line">-d：指定字段的分隔符，默认的字段分隔符为“TAB”；</span><br><span class="line">-f：显示指定字段的内容；</span><br><span class="line">-n：与“-b”选项连用，不分割多字节字符；</span><br><span class="line">--complement：补足被选择的字节、字符或字段；</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>例如有一个学生报表信息，包含 No、Name、Mark、Percent：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test.txt</span><br><span class="line">No Name Mark Percent</span><br><span class="line">01 tom 69 91</span><br><span class="line">02 jack 71 87</span><br><span class="line">03 alex 68 98</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用  <strong>-f</strong>  选项提取指定字段（这里的 f 参数可以简单记忆为 <code>--fields</code>的缩写）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f 1 test.txt</span><br><span class="line">No</span><br><span class="line">01</span><br><span class="line">02</span><br><span class="line">03</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2,3 test.txt</span><br><span class="line">Name Mark</span><br><span class="line">tom 69</span><br><span class="line">jack 71</span><br><span class="line">alex 68</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>–complement</strong>  选项提取指定字段之外的列（打印除了第二列之外的列）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2 --complement test.txt</span><br><span class="line">No Mark Percent</span><br><span class="line">01 69 91</span><br><span class="line">02 71 87</span><br><span class="line">03 68 98</span><br></pre></td></tr></table></figure>

<p>使用  <strong>-d</strong>  选项指定字段分隔符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test2.txt</span><br><span class="line">No;Name;Mark;Percent</span><br><span class="line">01;tom;69;91</span><br><span class="line">02;jack;71;87</span><br><span class="line">03;alex;68;98</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2 -d&quot;;&quot; test2.txt</span><br><span class="line">Name</span><br><span class="line">tom</span><br><span class="line">jack</span><br><span class="line">alex</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指定字段的字符或者字节范围"><a href="#指定字段的字符或者字节范围" class="headerlink" title="指定字段的字符或者字节范围"></a>指定字段的字符或者字节范围</h3><p>cut 命令可以将一串字符作为列来显示，字符字段的记法：</p>
<ul>
<li><strong>N-</strong> ：从第 N 个字节、字符、字段到结尾；</li>
<li><strong>N-M</strong> ：从第 N 个字节、字符、字段到第 M 个（包括 M 在内）字节、字符、字段；</li>
<li><strong>-M</strong> ：从第 1 个字节、字符、字段到第 M 个（包括 M 在内）字节、字符、字段。</li>
</ul>
<p>上面是记法，结合下面选项将摸个范围的字节、字符指定为字段：</p>
<ul>
<li><strong>-b</strong>  表示字节；</li>
<li><strong>-c</strong>  表示字符；</li>
<li><strong>-f</strong>  表示定义字段。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test.txt</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印第 1 个到第 3 个字符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c1-3 test.txt</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印前 2 个字符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c-2 test.txt</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印从第 5 个字符开始到结尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c5- test.txt</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>

<p>打印最后5个字符: </p>
<p>遗憾的是, <code>cut</code>并没有提供最后字符的支持. 不过我们可以通过字符串反转来实现. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test.txt| rev | cut -c -5 | rev</span><br><span class="line">vwxyz</span><br><span class="line">vwxyz</span><br><span class="line">vwxyz</span><br><span class="line">vwxyz</span><br><span class="line">vwxyz</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>用tee命令重定向标准输出</title>
    <url>/posts/aee075e4/</url>
    <content><![CDATA[<h1 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h1><p>从标准输入读取数据并重定向到标准输出和文件。主要用于，需要同时查看数据内容并输出到文件时使用。</p>
<span id="more"></span>

<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tee [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">FILE（可选）：要输出的文件，可以为一或多个。</span><br></pre></td></tr></table></figure>


<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">长选项与短选项等价</span><br><span class="line"></span><br><span class="line">-a, --append               追加到文件中而不是覆盖。</span><br><span class="line">-i, --ignore-interrupts    忽略中断信号（Ctrl+c中断操作无效）。</span><br><span class="line">-p                         诊断写入非管道的错误。</span><br><span class="line">--output-error[=MODE]      设置写错误时的行为，请查看下方的MODE部分。</span><br><span class="line">--help                     显示帮助信息并退出。</span><br><span class="line">--version                  显示版本信息并退出。</span><br><span class="line"></span><br><span class="line">MODE决定了当出现写错误时的输出行为，可用的MODE如下：</span><br><span class="line"></span><br><span class="line">&#x27;warn&#x27;           当写入到任何输出报错时诊断。</span><br><span class="line">&#x27;warn-nopipe&#x27;    当写入到任何输出（而不是管道）报错时诊断。</span><br><span class="line">&#x27;exit&#x27;           当写入到任何输出报错时退出。</span><br><span class="line">&#x27;exit-nopipe&#x27;    当写入到任何输出（而不是管道）报错时退出。</span><br><span class="line"></span><br><span class="line">-p选项的指定的默认MODE为&#x27;warn-nopipe&#x27;。</span><br><span class="line">当&#x27;--output-error&#x27;没有在选项中时，默认的操作是当写入到管道报错时立刻退出，诊断错误信息并写入到非管道输出。</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回状态为成功除非给出了非法选项或非法参数。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将进程信息通过管道输出到标准输出（终端）并覆盖写入到文件中。</span></span><br><span class="line">ps -ef |tee info_a.log info_b.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将进程信息通过管道输出到标准输出（终端）并追加写入到文件中。</span></span><br><span class="line">ps -ef |tee -a info_a.log info_b.log</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>用wc命令来统计字符数</title>
    <url>/posts/270bc33d/</url>
    <content><![CDATA[<h1 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h1><p>统计文件的字节数、字数、行数</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>wc命令</strong> 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。</p>
<span id="more"></span>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc(选项)(参数)</span><br><span class="line">wc [选项]... [文件]...</span><br><span class="line">wc [选项]... --files0-from=F</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c # 统计字节数，或--bytes：显示Bytes数。</span><br><span class="line">-l # 统计行数，或--lines：显示列数。</span><br><span class="line">-m # 统计字符数，或--chars：显示字符数。</span><br><span class="line">-w # 统计字数，或--words：显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</span><br><span class="line">-L # 打印最长行的长度，或--max-line-length。</span><br><span class="line">-help     # 显示帮助信息。</span><br><span class="line">--version # 显示版本信息。</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>文件：需要统计的文件列表。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc -l *       # 统计当前目录下的所有文件行数及总计行数。</span><br><span class="line">wc -l *.js    # 统计当前目录下的所有 .js 后缀的文件行数及总计行数。</span><br><span class="line">find  . * | xargs wc -l # 当前目录以及子目录的所有文件行数及总计行数。</span><br></pre></td></tr></table></figure>

<p>查看文件的字节数、字数、行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">7     8     70     test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">行数 单词数 字节数 文件名</span></span><br></pre></td></tr></table></figure>

<p>用wc命令怎么做到只打印统计数字不打印文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc -l &lt; test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>用来统计当前目录下的文件数(不包含隐藏文件)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要去除TOTAL行</span></span><br><span class="line">expr $(ls -l | wc -l) - 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>统计当前目录下的所有文件行数及总计行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# wc -l *</span><br><span class="line">      21 LICENSE</span><br><span class="line">     270 README.md</span><br><span class="line">wc: example: read: Is a directory</span><br><span class="line">     785 lerna-debug.log</span><br><span class="line">      25 lerna.json</span><br><span class="line">wc: node_modules: read: Is a directory</span><br><span class="line">   23603 package-lock.json</span><br><span class="line">      79 package.json</span><br><span class="line">       3 renovate.json</span><br><span class="line">   24786 total</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle构建</title>
    <url>/posts/af8dbea2/</url>
    <content><![CDATA[<p>Gradle Build Tool 是一种快速、可靠且适应性强的开源构建自动化工具，具有优雅且可扩展的声明性构建语言。</p>
<span id="more"></span>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>当我们执行<code>gradle init</code>命令后,gradle工具初始化项目工程，结构大致如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── gradle </span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew </span><br><span class="line">├── gradlew.bat </span><br><span class="line">├── settings.gradle </span><br><span class="line">├── build.gradle</span><br><span class="line">├── app</span><br><span class="line">│    ├── src</span><br><span class="line">│    └── build.gradle</span><br><span class="line">├── gradle.properties</span><br></pre></td></tr></table></figure>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="gradle-wrapper目录"><a href="#gradle-wrapper目录" class="headerlink" title="gradle wrapper目录"></a>gradle wrapper目录</h3><p>gradle文件中存在着wrapper文件夹，在wrapper下存在以下两个文件(gradle-wrapper.jar和gradle-wrapper.properties);</p>
<p>其中，gradle-wrapper.properties文件配置如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-7.0.2-bin.zip</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure>
<p>这里，distributionUrl会定义gradle工具包的下载地址。</p>
<p>当然，我们可以修改distributionUrl，来请求自己制品库里的gradle版本。</p>
<p>如果需要认证权限，可以在.gradle&#x2F;gradle.properties中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemProp.gradle.wrapperUser=</span><br><span class="line">systemProp.gradle.wrapperPassword=</span><br></pre></td></tr></table></figure>

<h3 id="gradlew和gradlew-bat"><a href="#gradlew和gradlew-bat" class="headerlink" title="gradlew和gradlew.bat"></a>gradlew和gradlew.bat</h3><p>可执行文件。如果没有在系统中配置gradle路径，那么我们可以使用.&#x2F;gradlew来执行任务，他会根据gradle-wrapper.properties中的下载地址，去下载gradle工具，完成下载后再执行任务</p>
<h3 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h3><p>整个项目的管理，包含哪些模块等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include &#x27;:app&#x27;</span><br><span class="line"></span><br><span class="line">project(&#x27;:utils&#x27;).projectDir = file(&#x27;utils&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h3><p>项目的一些配置属性，以key&#x3D;value的形式存在。还可以自定义一些属性，构建时使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemProp.http.proxyHost=</span><br><span class="line">systemProp.http.proxyPort=</span><br><span class="line"></span><br><span class="line">android.useAndroidX=true</span><br><span class="line"></span><br><span class="line">org.gradle.jvmargs=-Xmx1536m</span><br></pre></td></tr></table></figure>

<h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><p>构建脚本。除了工程根目录下有build.gradle外，每个module下也都有一个build.gradle。</p>
<h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h1><p>每个 project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。如编译，打包，生成 javadoc，发布到某个仓库等操作。</p>
<h2 id="查看默认的tasks"><a href="#查看默认的tasks" class="headerlink" title="查看默认的tasks"></a>查看默认的tasks</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew tasks --all</span><br></pre></td></tr></table></figure>
<p>可以查看所有的tasks</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Build tasks</span><br><span class="line">-----------</span><br><span class="line">app:assemble - Assembles the outputs of this project.</span><br><span class="line">app:build - Assembles and tests this project.</span><br><span class="line">app:buildDependents - Assembles and tests this project and all projects that depend on it.</span><br><span class="line">app:buildNeeded - Assembles and tests this project and all projects it depends on.</span><br><span class="line">app:classes - Assembles main classes.</span><br><span class="line">app:clean - Deletes the build directory.</span><br><span class="line">app:jar - Assembles a jar archive containing the main classes.</span><br><span class="line">app:testClasses - Assembles test classes.</span><br><span class="line">...</span><br><span class="line">Verification tasks</span><br><span class="line">------------------</span><br><span class="line">app:check - Runs all checks.</span><br><span class="line">app:test - Runs the unit tests.</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以发现其他比较有用的task</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app:properties - Displays the properties of project &#x27;:app&#x27;.</span><br><span class="line">app:dependencies - Displays all dependencies declared in project &#x27;:app&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="自定义一个task"><a href="#自定义一个task" class="headerlink" title="自定义一个task"></a>自定义一个task</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    println System.getenv(&quot;PATH&quot;)</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &#x27;Hello world!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行<code>./gradlew [Task名]</code>就可以调用该task。<br>上面的示例中，doLast,doFirst指的是在执行阶段，而不是Configure阶段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Configure project :app</span><br><span class="line">/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin:/Library/Apple/usr/bin</span><br><span class="line"></span><br><span class="line">&gt; Task :app:printTaskProperties</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>

<h2 id="groovy语法"><a href="#groovy语法" class="headerlink" title="groovy语法"></a>groovy语法</h2><p>task中可以采用groovy语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task outputDescription&#123;</span><br><span class="line">    new File(&quot;description.txt&quot;).withWriter(&#x27;utf-8&#x27;)&#123;</span><br><span class="line">        writer -&gt; writer.writeLine &quot;line&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task count&#123;</span><br><span class="line">    4.times &#123; print &quot;$it &quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出一个文件description.txt，同时终端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ./gradlew outputDescription</span><br><span class="line"></span><br><span class="line">&gt; Configure project :app</span><br><span class="line">0 1 2 3</span><br><span class="line">BUILD SUCCESSFUL in 487ms</span><br></pre></td></tr></table></figure>

<h2 id="为task自定义属性"><a href="#为task自定义属性" class="headerlink" title="为task自定义属性"></a>为task自定义属性</h2><p>你可以为一个任务添加额外的属性。例如,新增一个叫做 myProperty 的属性，用 ext.myProperty 的方式给他一个初始值。这样便增加了一个自定义属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task myTask &#123;</span><br><span class="line">    ext.myProperty = &quot;myValue&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printTaskProperties &#123;</span><br><span class="line">    doFirst&#123;</span><br><span class="line">        println myTask.myProperty</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h1><h2 id="dependsOn"><a href="#dependsOn" class="headerlink" title="dependsOn"></a>dependsOn</h2><p>在两个任务之间可以指明依赖关系。<br>动态创建4个task,然后指定task0依赖task2，task3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.times &#123; counter -&gt;</span><br><span class="line">    task &quot;task$counter&quot; &#123;</span><br><span class="line">        doLast&#123;</span><br><span class="line">            println &quot;I&#x27;m task number $counter&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task0.dependsOn task2, task3</span><br></pre></td></tr></table></figure>
<p>接着执行task0，他会优先执行task2，task3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ./gradlew task0</span><br><span class="line"></span><br><span class="line">&gt; Task :app:task2</span><br><span class="line">I&#x27;m task number 2</span><br><span class="line"></span><br><span class="line">&gt; Task :app:task3</span><br><span class="line">I&#x27;m task number 3</span><br><span class="line"></span><br><span class="line">&gt; Task :app:task0</span><br><span class="line">I&#x27;m task number 0</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 375ms</span><br><span class="line">3 actionable tasks: 3 executed</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="finalizedBy"><a href="#finalizedBy" class="headerlink" title="finalizedBy"></a>finalizedBy</h2><p>finalizedBy 是指一个 Task 在执行完毕后，会执行另一个 Task。也就是说，被依赖的 Task 后执行，然后才能执行依赖它的 Task</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task myFirstTask &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;This is my first task&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task mySecondTask &#123;</span><br><span class="line">    finalizedBy myFirstTask</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;This is my second task&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了两个 Task，myFirstTask 和 mySecondTask。在 mySecondTask 中使用 finalizedBy 方法来指定它在执行完毕后会执行 myFirstTask。因此，mySecondTask 先执行，然后才能执行 myFirstTask</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>可以分为三个部分：初始化阶段、配置阶段和执行阶段</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>Initialization初始化阶段<br>Gradle为每个module创建了一个Project实例，在多module的项目构建过程中，Gradle会找出哪些Project实例需要参与到项目的构建中，本质上也就是执行settings.gradle脚本，从而读取整个项目中有多少个Project实例。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>配置阶段的任务是执行各module下的build.gradle脚本，从而完成Project的配置，并且构造Task任务依赖关系图以便在执行阶段按照依赖关系执行Task。</p>
<h2 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h2><p>在配置阶段结束后，Gradle会根据任务Task的依赖关系会创建一个有向无环图，还可以通过Gradle对象的getTaskGraph方法访问，对应的类是TaskExecutionGraph，然后通过调用.&#x2F;gradlew &lt;任务&gt; 来执行对应的任务</p>
<h2 id="project的两个监听方法"><a href="#project的两个监听方法" class="headerlink" title="project的两个监听方法"></a>project的两个监听方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在 Project 进行配置前调用 </span><br><span class="line">void beforeEvaluate(Closure closure)</span><br><span class="line"></span><br><span class="line">//在 Project 配置结束后调用 </span><br><span class="line">void afterEvaluate(Closure closure)</span><br></pre></td></tr></table></figure>

<h2 id="生命周期流程展示"><a href="#生命周期流程展示" class="headerlink" title="生命周期流程展示"></a>生命周期流程展示</h2><p>在setting.gradle中进行如下配置,并在gradle.properties中定义<strong>MYVAR&#x3D;abcd</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rootProject.name = &#x27;root&#x27;</span><br><span class="line">include(&#x27;app&#x27;, &#x27;list&#x27;, &#x27;utilities&#x27;)</span><br><span class="line"></span><br><span class="line">println &#x27;初始化阶段开始...&#x27;</span><br><span class="line">println MYVAR</span><br></pre></td></tr></table></figure>
<p>在项目根目录添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对子模块进行配置</span><br><span class="line">subprojects &#123; sub -&gt;</span><br><span class="line">    sub.beforeEvaluate &#123; proj -&gt;</span><br><span class="line">        println &quot;子项目beforeEvaluate回调...&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接执行<code>./gradlew projects</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ./gradlew projects</span><br><span class="line">初始化阶段开始...</span><br><span class="line">abcd</span><br><span class="line"></span><br><span class="line">&gt; Configure project :app</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line"></span><br><span class="line">&gt; Configure project :list</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line"></span><br><span class="line">&gt; Configure project :utilities</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line"></span><br><span class="line">&gt; Task :projects</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project &#x27;root&#x27;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Root project &#x27;root&#x27;</span><br><span class="line">+--- Project &#x27;:app&#x27;</span><br><span class="line">+--- Project &#x27;:list&#x27;</span><br><span class="line">\--- Project &#x27;:utilities&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到，在Initialization阶段，settings.gradle中的打印先输出,并且读取了gradle.properties中的变量。然后是读各个子项目的配置，最后是我们要运行的task。</p>
<p>然后我们在app的build.gradle中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">println &quot;app project配置开始&quot;</span><br><span class="line"></span><br><span class="line">afterEvaluate &#123;</span><br><span class="line">    println &quot;app project afterEvaluate回调...&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task appTest &#123;</span><br><span class="line">    println &quot;app project appTest任务配置&quot;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;执行子项目任务...&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续执行.&#x2F;gradlew projects</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ./gradlew projects</span><br><span class="line">初始化阶段开始...</span><br><span class="line">abcd</span><br><span class="line"></span><br><span class="line">&gt; Configure project :app</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line">app project配置开始</span><br><span class="line">app project appTest任务配置</span><br><span class="line">app project afterEvaluate回调...</span><br><span class="line"></span><br><span class="line">&gt; Configure project :list</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line"></span><br><span class="line">&gt; Configure project :utilities</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line"></span><br><span class="line">&gt; Task :projects</span><br></pre></td></tr></table></figure>
<p>可以看到即使是appTest这个task的闭包中的配置项也是被调用的。但是doLast并没有执行。只有.&#x2F;gradlew appTest才会有该日志</p>
<h2 id="监听gradle生命周期"><a href="#监听gradle生命周期" class="headerlink" title="监听gradle生命周期"></a>监听gradle生命周期</h2><p>在settings.gradle中添加如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">core-api/org/gradle/api/invocation/Gradle.java</span><br><span class="line">core-api/org/gradle/BuildListener.java</span><br><span class="line">gradle.addBuildListener(new BuildListener()&#123;</span><br><span class="line">    void buildStarted(Gradle gradle)&#123;</span><br><span class="line">        println &quot;buildStarted&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //settings.gradle配置完后调用，只对settings.gradle设置生效，此时未完成 Project 的初始化</span><br><span class="line">    void settingsEvaluated(Settings settings)&#123;</span><br><span class="line">        println &quot;settingsEvaluated&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化阶段结束</span><br><span class="line">    void projectsLoaded(Gradle gradle)&#123;</span><br><span class="line">        println &quot;projectsLoaded&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //所有project配置完成后调用</span><br><span class="line">    void projectsEvaluated(Gradle gradle)&#123;</span><br><span class="line">        println &quot;projectsEvaluated&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void buildFinished(BuildResult result)&#123;</span><br><span class="line">        println &quot;buildFinished&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>继续执行.&#x2F;gradlew appTest</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ./gradlew appTest</span><br><span class="line">初始化阶段开始...</span><br><span class="line">settingsEvaluated</span><br><span class="line">projectsLoaded</span><br><span class="line"></span><br><span class="line">&gt; Configure project :app</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line">app project配置开始</span><br><span class="line">app project appTest任务配置</span><br><span class="line">app project afterEvaluate回调...</span><br><span class="line"></span><br><span class="line">&gt; Configure project :list</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line"></span><br><span class="line">&gt; Configure project :utilities</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line">projectsEvaluated</span><br><span class="line"></span><br><span class="line">&gt; Task :app:appTest</span><br><span class="line">执行子项目任务...</span><br><span class="line">buildFinished</span><br></pre></td></tr></table></figure>

<h2 id="监听task的生命周期"><a href="#监听task的生命周期" class="headerlink" title="监听task的生命周期"></a>监听task的生命周期</h2><p>Gradle在配置完成之后，会对所有的task生成一个有向无环图，这里叫做task执行图。也就是TaskExecutionGraph这个类。添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.taskGraph.whenReady&#123;</span><br><span class="line">    println &quot;task whenReady&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后可以看到他是在projectsEvaluated完成后调用。</p>
<p>对于任务的监听，可以通过TaskExecutionListener接口来实现。这个接口定义了4个方法：</p>
<ul>
<li>beforeExecute(Task task)：在任务执行之前调用。</li>
<li>afterExecute(Task task, TaskState state)：在任务执行之后调用。</li>
<li>beforeActions(Task task)：在任务执行动作之前调用。</li>
<li>afterActions(Task task)：在任务执行动作之后调用。</li>
</ul>
<p>具体可见core-api&#x2F;org&#x2F;gradle&#x2F;api&#x2F;execution&#x2F;TaskExecutionListener.java</p>
<p>而taskGraph提供了添加增加监听的方法addTaskExecutionListener</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.taskGraph.addTaskExecutionListener(new TaskExecutionListener()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            void beforeExecute(Task t) &#123;</span><br><span class="line">                println &quot;Task $&#123;t.name&#125; is about to execute&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            void afterExecute(Task t, TaskState state) &#123;</span><br><span class="line">                println &quot;Task $&#123;t.name&#125; has finished executing&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle插件</title>
    <url>/posts/8f0b2ecf/</url>
    <content><![CDATA[<h1 id="gradle插件"><a href="#gradle插件" class="headerlink" title="gradle插件"></a>gradle插件</h1><p>所有有用的功能，例如以能够编译 Java 代码为例，都是通过插件进行添加的。</p>
<span id="more"></span>
<h2 id="应用二进制插件"><a href="#应用二进制插件" class="headerlink" title="应用二进制插件"></a>应用二进制插件</h2><p>什么是二进制插件呢？二进制插件就是实现了org.gradle.api.Plugin接口的插件，他们可以有plugin id，下面我们看下如何应用一个java插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin:&#x27;java&#x27;</span><br></pre></td></tr></table></figure>
<p>这样我们把java插件应用到我们的项目中了，其中’java’是Java插件的plugin id，他是唯一的，对于Gradle自带的核心插件都有一个容易记的短名称作为其plugin id，比如这里的java，其实它对应类型的是org.gradle.api.plugins.JavaPlugin，所以通过该类型我们也可以应用这个插件。</p>
<p>又因为包org.gradle.api.plugins是默认导入的，所以我们可以去掉包名直接写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;org.gradle.api.plugins.JavaPlugin&#x27;</span><br><span class="line">apply plugin: &#x27;JavaPlugin&#x27;</span><br></pre></td></tr></table></figure>

<p>以前三种写法是等价的</p>
<h2 id="应用脚本插件"><a href="#应用脚本插件" class="headerlink" title="应用脚本插件"></a>应用脚本插件</h2><p>应用脚本插件，其实就是把这个脚本加载进来，和二进制 插件不同的是它使用的是from关键字，后面紧跟的是一个脚本文件，可以是本地的，也可以是网络的，如果是网络上的话要使用HTTP URL。</p>
<p>虽然它不是一个真正的插件，但是不能忽视它的作用，它是脚本文件模块化的基础，我们可以把庞大的脚本文件，进行分块、分段整理，拆分成一个个共用、职责分明的文件，然后使用apply from来引用他们，比如我们可以把常用的函数放在一个utils.gradle脚本里，供其他脚本文件引用。</p>
<p>我们把App的版本名称和版本号单独放在一个脚本文件里，这样我们每次只需要在这个文件修改App的版本名称和版本号即可，清晰、简单、方便、快捷，也可以使用自动化对该文件自动处理生成版本等等。</p>
<h2 id="应用第三方插件"><a href="#应用第三方插件" class="headerlink" title="应用第三方插件"></a>应用第三方插件</h2><p>第三方发布的作为jar的二进制插件，我们在应用的时候，必须要现在buildscript{}里配置其classpath才能使用，这个不像Gradle为我们提供的内置插件。比如我们的Android Gradle插件，就属于Android发布的第三方插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;com.android.application&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="插件作用"><a href="#插件作用" class="headerlink" title="插件作用"></a>插件作用</h2><p>插件为我们的gradle添加了新的任务，配置了一些构建需要的属性。比如，Java 插件已经向项目添加了 compileJava 任务和 processResources 任务，并且配置了这两个任务的 destinationDir 属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">println relativePath(compileJava.destinationDir)</span><br><span class="line">println relativePath(processResources.destinationDir)</span><br></pre></td></tr></table></figure>

<h1 id="自定义gradle插件"><a href="#自定义gradle插件" class="headerlink" title="自定义gradle插件"></a>自定义gradle插件</h1><p>对于一些复杂的构建功能，我们需要通过自定义gradle插件来扩展</p>
<h2 id="buildSrc"><a href="#buildSrc" class="headerlink" title="buildSrc"></a>buildSrc</h2><p>在 Gradle 中，buildSrc是一个特殊的目录，用于存放构建脚本的代码，它不需要在setting.gradle中include进来，也会被识别。</p>
<p>buildSrc目录下的代码可以被构建脚本直接引用。</p>
<p>buildSrc目录下的代码会在构建脚本之前编译和执行。所以他不会读到gradle.properties中定义的全局变量。</p>
<p>我们在buildSrc&#x2F;src&#x2F;main&#x2F;groovy中创建HelloPlugin.groovy文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.gradle.api.Plugin;</span><br><span class="line">import org.gradle.api.Project;</span><br><span class="line">import org.gradle.api.Task;</span><br><span class="line">import org.gradle.api.Action;</span><br><span class="line"></span><br><span class="line">public class HelloPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void apply(Project project) &#123;</span><br><span class="line">        println(&quot;this is HelloPlugin&quot;);</span><br><span class="line">        project.getTasks().create(&quot;HelloTask&quot;, new Action&lt;Task&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void execute(Task task) &#123;</span><br><span class="line">                println(&quot;this is HelloPluginTask&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，我们就创建了一个HelloTask。</p>
<p>然后在app&#x2F;build.gradle中引用该插件<code>apply plugin: HelloPlugin</code>,然后我们执行<code>./gradlew tasks --all</code>。结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % ./gradlew tasks --all</span><br><span class="line">初始化阶段开始...</span><br><span class="line">settingsEvaluated</span><br><span class="line">projectsLoaded</span><br><span class="line"></span><br><span class="line">&gt; Configure project :app</span><br><span class="line">子项目beforeEvaluate回调...</span><br><span class="line">this is HelloPlugin</span><br><span class="line">this is HelloPluginTask</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h2><p>仿照buildSrc目录的build.gradle，我们也需要增加groovy-gradle-plugin插件，这样我们就可以对groovy代码进行构建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &#x27;groovy-gradle-plugin&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    gradlePluginPortal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而gradlePluginPortal 是一个在线的 Gradle 插件仓库，它提供了大量的 Gradle 插件供开发者使用。在 Gradle 5.0 及以上版本中，gradlePluginPortal 被默认添加到了 Gradle 的插件仓库列表中。</p>
<p>使用 gradlePluginPortal 可以方便地查找和引用第三方 Gradle 插件。当你在 Gradle 构建文件中声明一个插件时，Gradle 会自动从 gradlePluginPortal 中下载该插件的相关信息和依赖项，并在构建过程中使用该插件</p>
<p>完成插件代码后。还需要指明插件入口。<br>在src&#x2F;main&#x2F;目录下创建resources&#x2F;META-INF&#x2F;gradle-plugins&#x2F;xxxx.properties<br>其中xxxx将是apply plugin: xxxx的名称。</p>
<p>而properties的具体内容是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation-class=插件的全类名</span><br></pre></td></tr></table></figure>

<p>例如：android gradle 插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.android.application.properties:</span><br><span class="line"></span><br><span class="line">implementation-class=com.android.build.gradle.AppPlugin</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>java与jvm</title>
    <url>/posts/866be044/</url>
    <content><![CDATA[<h2 id="JDK-JRE-JVM是什么"><a href="#JDK-JRE-JVM是什么" class="headerlink" title="JDK,JRE,JVM是什么"></a>JDK,JRE,JVM是什么</h2><p>Java是一门编程语言。而JDK是Java开发工具包,是整个 Java 开发的核心。它提供了 Java 的开发环境，JAVA API类库(都在lib目录下打包成了jar)，以及一些好用的小工具(有<code>javac.exe</code>,<code>javap.exe</code>，可以在<code>java/jdk/bin/</code>目录下查看)和 Java的运行环境</p>
<p>而其中运行时环境就是我们说的<strong>JRE</strong>。JRE主要包含两个部分，<strong>jvm 的标准实现和 Java 的一些基本类库</strong>。</p>
<p><strong>JVM</strong>——我们耳熟能详的 Java 虚拟机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。所以说，jvm 是 Java 能够跨平台的核心。</p>
<span id="more"></span>

<p><img src="/images/jdk.PNG" alt="jdk"></p>
<h2 id="什么是虚拟机"><a href="#什么是虚拟机" class="headerlink" title="什么是虚拟机"></a>什么是虚拟机</h2><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<ul>
<li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>Java虚拟机是一台执行Java字节码的虚拟计算机，运行在操作系统之上的，它与硬件没有直接的交互。</p>
<p>它拥有独立的运行机制，优秀的垃圾回器，以及可靠的即时编译器。</p>
<p>它将负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<p>它的整体结构如下:</p>
<p><img src="/images/jvm.png" alt="jvm结构"></p>
<h2 id="基于栈的指令集架构"><a href="#基于栈的指令集架构" class="headerlink" title="基于栈的指令集架构"></a>基于栈的指令集架构</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>
<p>基于栈式架构的特点：</p>
<ol>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ol>
<p>基于寄存器架构的特点：</p>
<ol>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>
<li>指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li>
</ol>
<h3 id="两种架构的举例"><a href="#两种架构的举例" class="headerlink" title="两种架构的举例"></a>两种架构的举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p>
<p>基于栈的计算流程（以Java虚拟机为例):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconst_2 //常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3 // 常量3入栈</span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd //常量2/3出栈，执行相加</span><br><span class="line">istore_0 // 结果5入栈</span><br></pre></td></tr></table></figure>
<p>8个指令，</p>
<p>而基于寄存器的计算流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,2 //将eax寄存器的值设为1</span><br><span class="line">add eax,3 //使eax寄存器的值加3</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载子系统</title>
    <url>/posts/13cb3a0e/</url>
    <content><![CDATA[<h2 id="类加载子系统作用"><a href="#类加载子系统作用" class="headerlink" title="类加载子系统作用"></a>类加载子系统作用</h2><ol>
<li>类加载子系统负责从文件系统或者网络中加载Class文件</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，由执行引擎决定</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放**运行时常量池信息(Constant pool)**，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ol>
<span id="more"></span>

<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="/images/loader.png" alt="loader"></p>
<p>如果想要执行某个类的静态main方法。要经历 <strong>加载-》链接-》初始化-》调用</strong> 这些步骤</p>
<h3 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h3><p>此处的加载是指loading</p>
<ol>
<li>通过一个类的全限定名获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的Class对象，作为这个类的各种数据的访问入口</li>
</ol>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值。这里不包含用final修饰的static，因为final在编译(java变成class)的时候就会分配好了默认值，准备阶段会显式初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassInitTest &#123;</span><br><span class="line">    public static int num = 3; //在prepare阶段 num会被赋予初值0；在后面初始化阶段，赋值为3。</span><br><span class="line">                               //在prepare阶段 若是引用对象，初始值为null</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</strong></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>** 将常量池内的符号引用转换为直接引用的过程** </p>
<p>比如我们要在内存中找一个类里面的一个叫做show的方法，显然是找不到。但是在解析阶段，jvm就会把show这个名字转换为指向方法区的的一块内存地址，比如c17164，通过c17164就可以找到show这个方法具体分配在内存的哪一个区域了。这里show就是符号引用，而c17164就是直接引用。<strong>在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。</strong></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类的初始化时机:</p>
<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如：Class.forName(“com.atguigu.Test”)）</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p>
<h4 id="clinit-方法"><a href="#clinit-方法" class="headerlink" title="clinit()方法"></a>clinit()方法</h4><p>初始化阶段就是执行类构造器方法<clinit>()的过程</p>
<ol>
<li>此方法不需定义，<strong>是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</strong>。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li>
<li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器<code>&lt;init&gt;()</code>。（init()每次创建实例对象时调用）</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁 ,它只会执行一次</li>
</ol>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    private int i = test();</span><br><span class="line">    private static int j = method();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;1 父类静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.println(&quot;2 父类无参构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;3 父类代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int test() &#123;</span><br><span class="line">        System.out.println(&quot;4 父类 test 方法&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int method() &#123;</span><br><span class="line">        System.out.println(&quot;5 父类 method 方法&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Father&#123;</span><br><span class="line"></span><br><span class="line">    private int i = test();</span><br><span class="line"></span><br><span class="line">    private static int j = method();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;6 子类静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son() &#123;</span><br><span class="line">        System.out.println(&quot;7 子类无参构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;8 子类代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int test() &#123;</span><br><span class="line">        System.out.println(&quot;9 子类 test 方法&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int method() &#123;</span><br><span class="line">        System.out.println(&quot;10 子类 method 方法&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们new一个son实例时，会发生什么？正确输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 父类 method 方法</span><br><span class="line">1 父类静态代码块</span><br><span class="line">10 子类 method 方法</span><br><span class="line">6 子类静态代码块</span><br><span class="line">9 子类 test 方法</span><br><span class="line">3 父类代码块</span><br><span class="line">2 父类无参构造器</span><br><span class="line">9 子类 test 方法</span><br><span class="line">8 子类代码块</span><br><span class="line">7 子类无参构造函数</span><br></pre></td></tr></table></figure>

<p>我们知道在实例化对象前，在实例化对象前，jvm 需要去方法区找有没有这个对象对应的class文件。由于Son类有父类，按照规则又会先去看看父类初始化没有。</p>
<p>如果father 类没有初始化，所以又先去调用<code>Father.&lt;clinit&gt;()</code>方法。而<code>&lt;clinit&gt;()</code>方法由静态类变量显式赋值代码、静态代码块组成。谁在前，谁先执行。<code>Father.&lt;clinit&gt;()</code>结束，开时执行子类的<code>Son.&lt;clinit&gt;()</code>方法。所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 父类 method 方法</span><br><span class="line">1 父类静态代码块</span><br><span class="line">10 子类 method 方法</span><br><span class="line">6 子类静态代码块</span><br></pre></td></tr></table></figure>

<p>类初始化之后，就是对象实例化.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Son() &#123;</span><br><span class="line">    // 这句写或者不写，都一定会执行，子类构造器一定会调用父类构造器。</span><br><span class="line"> // super();</span><br><span class="line">    System.out.println(&quot;7 子类无参构造函数&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们知道子类构造器中有super的调用。所以，<code>Son.&lt;init&gt;</code>执行前先调用<code>Father.&lt;init&gt;</code></p>
<p>然后我们知道每次构造会执行：</p>
<ol>
<li>成员变量的赋值代码</li>
<li>非静态代码块，和第一条，谁先出现，谁先执行</li>
<li>对应构造器代码【最后执行】</li>
</ol>
<p>接着，我们得到这样的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 子类 test 方法</span><br><span class="line">3 父类代码块</span><br><span class="line">2 父类无参构造器</span><br><span class="line">9 子类 test 方法</span><br><span class="line">8 子类代码块</span><br><span class="line">7 子类无参构造函数</span><br></pre></td></tr></table></figure>

<p>但是,我们这里结果的第一行我们按照预期以为应该是打印的：4 父类 test 方法。但是实际却是:9 子类 test 方法</p>
<p>原本该是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    private int i = this.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，子类重写了test方法。运行时，此时Father中的this指的是Son类。这个就是java的多态。</p>
<p>我们可以另外验证一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Father() &#123;</span><br><span class="line">    System.out.println(this.getClass().getName());   =&gt; 返回Son</span><br><span class="line">    System.out.println(&quot;2 父类无参构造器&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载器分类</title>
    <url>/posts/dd617b0c/</url>
    <content><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>它的主要作用是查找和加载Class文件到JVM中。</p>
<p>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong> ,例如:  扩展类加载器(Extension ClassLoader),应用程序类加载器(App ClassLoader)</p>
<span id="more"></span>
<h2 id="Bootstrap引导类加载器"><a href="#Bootstrap引导类加载器" class="headerlink" title="Bootstrap引导类加载器"></a>Bootstrap引导类加载器</h2><ol>
<li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部</li>
<li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自java.lang.ClassLoader，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
</ol>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><ol>
<li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class ExtClassLoader extends URLClassLoader &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h2><ol>
<li>Java语言编写，由<code>sun.misc.Launchers$AppClassLoader</code>实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class AppClassLoader extends URLClassLoader &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，AppClassLoader父类是URLClassLoader，但是AppClassLoader的父类加载器是ExtClassLoader。而ExtClassLoader的父类加载器是引导类加载器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //获取系统类加载器</span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">        //获取其上层：扩展类加载器</span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line"></span><br><span class="line">        //获取其上层：获取不到引导类加载器</span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);//null</span><br><span class="line"></span><br><span class="line">        //对于用户自定义类来说：默认使用系统类加载器进行加载</span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">        //String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);//null</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>它是一个抽象类。其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getParent()</td>
<td align="center">获得父类加载器</td>
</tr>
<tr>
<td align="center">loadClass(name)</td>
<td align="center">加载名为name类</td>
</tr>
<tr>
<td align="center">findClass(name)</td>
<td align="center">查找名为name的类</td>
</tr>
</tbody></table>
<p>我们可以通过如下几个方法获得ClassLoader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1</span><br><span class="line">ClassLoader classLoader = Class.forName(&quot;java.lang.String&quot;).getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">ClassLoader classLoader1 = Thread.currentThread().getContextClassLoader();</span><br><span class="line">System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">//3.</span><br><span class="line">ClassLoader classLoader2 = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">System.out.println(classLoader2);</span><br></pre></td></tr></table></figure>

<h1 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h1><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即<code>ClassNotFoundException</code>），子加载器才会尝试自己去加载</p>
<p><strong>更安全</strong>有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">public class String &#123;</span><br><span class="line">    //</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;我是自定义的String类的静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //错误: 在类 java.lang.String 中找不到 main 方法</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello,String&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外如果定义了一个类，包名为java.lang，也会报错<code>java.lang.SecurityException: Prohibited package name: java.lang</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line"></span><br><span class="line">public class ShkStart &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时<strong>避免了重复加载</strong>，直接读取已经加载的Class即可。</p>
<p>当前类加载器和所有父类加载器都无法加载该类时，抛出ClassNotFindException异常</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h2><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ol>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</li>
</ol>
<p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p>
<h2 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h2><ol>
<li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li>
<li>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</li>
<li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li>
</ol>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>运行时数据区</title>
    <url>/posts/11595de/</url>
    <content><![CDATA[<p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取。Java虚拟机在执行Java程序的过程中会将其管理的内存划分为不同的数据区域</p>
<span id="more"></span>

<p><img src="/images/10006199-a4108d8fb7810a71.png" alt="运行时数据区"></p>
<p>其中方法区跟堆都是随着虚拟机启动而创建，随着虚拟机退出而销毁。是多个线程共享的。</p>
<p>而 <strong>虚拟机栈，本地方法栈，程序计数器</strong>，每个线程都各有一份，是私有的</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>它并非是广义上所指的物理寄存器，是JVM对物理PC寄存器的一种抽象模拟。</p>
<p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。<strong>它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    int j = 20;</span><br><span class="line">    int k = i + j;</span><br><span class="line"></span><br><span class="line">    String s = &quot;abc&quot;;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用javap反编译字节码后，得到指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=5, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: bipush        20</span><br><span class="line">         5: istore_2</span><br><span class="line">         6: iload_1</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: iadd</span><br><span class="line">         9: istore_3</span><br><span class="line">        10: ldc           #2                  // String abc</span><br><span class="line">        12: astore        4</span><br><span class="line">        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        17: iload_1</span><br><span class="line">        18: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        21: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        24: iload_3</span><br><span class="line">        25: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        28: return</span><br></pre></td></tr></table></figure>
<p>这前面0，2，3，5… 数字表示的是指令地址，也叫偏移地址。bipush，iadd，istore_1，iload_1表示的是操作指令。后面的<code>#数字</code>则是运行时常量池中的符号引用。</p>
<p>PC寄存器是线程私有的。我们都知道在多线程场景下，CPU会不停地做任务切换，这样必然导致经常中断或恢复。为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>它的生命周期与线程相同，与线程是同时创建的。每个方法被执行的时候都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。</p>
<p>一个Java虚拟机栈包含了很多个栈帧。<strong>一个栈帧用来存储局部变量表，操作数栈，动态链接，方法返回值等信息</strong></p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>虚拟机可能用到C来实现Native语言。它与虚拟机栈基本类似，也会抛出StackOverflowError和OOM</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>几乎所有对象实例都在这里分配内存。存放new生成的对象和数组</p>
<p>是虚拟机管理的内存中最大的一块</p>
<p>是所有线程共享的区域</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。是线程共享的</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>Class文件不仅包含类的版本，接口，字段和方法等信息，还包含常量池，它用来存放编译时期生成的字面量和符号引用，这些内容会在类加载后存放在方法区的运行时常量池</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机栈</title>
    <url>/posts/594d8429/</url>
    <content><![CDATA[<p>Java虚拟机栈也叫java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，栈是线程私有的，是一个后入先出的栈。</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收问题,但是可能存在OOM</li>
</ul>
<h2 id="栈大小"><a href="#栈大小" class="headerlink" title="栈大小"></a>栈大小</h2><ol>
<li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError(栈溢出) 异常。</p>
</li>
<li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutofMemoryError(内存溢出) 异常。</p>
</li>
</ol>
<p><strong>如何设置栈大小？</strong><br>可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<p>设置线程栈大小,可以以字节表示，以字母k或K表示KB，以字母m或M表示MB，以字母g或G表示GB。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体是Run/Debug Configurations -&gt; VM options 中加入下面任意</span><br><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure>
<p>都是设置为1M大小</p>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，每个方法都各自对应一个栈帧。<strong>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）</strong></p>
<p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
</ul>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</p>
<p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p>局部变量表中的变量只在当前方法调用中有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int fun()&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    return 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如这样一个方法，通过jclasslib查看字节码<br><img src="/images/localvar.png" alt="localvar"><br>同时在杂项中，我们可以看到其他信息<br><img src="/images/localvar2.png" alt="localvar2"></p>
<p>如图得到了一个重要的信息，最大槽数为4。<br><strong>什么是槽？</strong><br>局部变量表，最基本的存储单元是Slot（变量槽）。在局部变量表里，32位以内的类型(byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true)只占用一个slot（包括returnAddress类型），64位的类型占用两个slot（1ong和double）。参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。局部变量将会<strong>按照代码顺序</strong>被复制到局部变量表中的每一个slot上</p>
<p><strong>具体有哪些局部变量呢？</strong><br>我们可以在LocalVariableTable中查看<br><img src="/images/localvar3.png" alt="localvar3"></p>
<p>图中，起始PC表示的是字节码的偏移地址，长度表示这个变量的作用范围，序号表示变量在槽中的索引，名字也就是变量名。</p>
<p>我们可以看到，第一个变量是this，放在了slot为0的位置，所以成员方法可以使用成员属性。而在static方法的局部变量表中没有this。</p>
<p>另外，slot是可以重复利用的。如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    &#123;</span><br><span class="line">        int b = 0;</span><br><span class="line">        b = a + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //变量c使用之前已经销毁的变量b占据的slot的位置</span><br><span class="line">    int c = a + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>也在编译的时候就确定了，被写入到了 Code 属性的 maximum stack size 中。当一个方法刚开始执行的时候，操作数栈是空的，在方法执行过程中，会有各种字节码指令往操作数栈中写入和取出数据，也就是入栈和出栈操作。</p>
<p>例如下面这代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int fun(int a,int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的字节码指令是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 iload_1           -&gt; 用于将局部变量表中下标为 1 的 int 类型变量加载到操作数栈上（下标为 0 的是 this）</span><br><span class="line">1 iload_2           -&gt; 用于将局部变量表中下标为 2 的 int 类型变量加载到操作数栈上；</span><br><span class="line">2 iadd              -&gt; 用于 int 类型的加法运算,运算完后，将操作数取出栈，再把结果压入栈</span><br><span class="line">3 ireturn           -&gt; 为返回值为 int 的方法返回指令</span><br></pre></td></tr></table></figure>
<p>所以操作数栈的最大深度是2。与slot类似，32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。当类加载加载的时候，会将用于存放编译期生成的各种字面量和符号引用放在运行时常量池中</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ul>
<li>正常退出</li>
<li>异常退出</li>
</ul>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此接下来可能执行的操作有：恢复上层方法的局部变量表和操作数栈，<strong>把返回值（如果有的话）压入调用者栈帧的操作数栈中</strong>，调整 PC 计数器的值，找到下一条要执行的指令等。</p>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定</p>
<p>异常处理表：</p>
<ul>
<li>from ：字节码指令起始地址</li>
<li>to ：字节码指令结束地址</li>
<li>target ：出现异常跳转至地址为 11 的指令执行</li>
<li>type ：捕获异常的类型</li>
</ul>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>方法的调用</title>
    <url>/posts/6aa965b7/</url>
    <content><![CDATA[<p><strong>java是有多态的特性的，那么在有重写，重载的状况下，jvm是怎么知道需要调用哪个方法的呢？</strong></p>
<p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li><p>静态链接：<br>当一个字节码文件被装载进JVM内部时，<strong>如果被调用的目标方法在编译期确定，且运行期保持不变时</strong>，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
</li>
<li><p>动态链接：<br>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<span id="more"></span></li>
</ul>
<p><strong>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p>
<ul>
<li><p>早期绑定<br>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</li>
<li><p>晚期绑定<br>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;动物进食&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Huntable &#123;</span><br><span class="line">    void hunt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal implements Huntable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;狗吃骨头&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hunt() &#123;</span><br><span class="line">        System.out.println(&quot;捕食耗子，多管闲事&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal implements Huntable &#123;</span><br><span class="line"></span><br><span class="line">    public Cat() &#123;</span><br><span class="line">        super();//表现为：早期绑定</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Cat(String name) &#123;</span><br><span class="line">        this();//表现为：早期绑定</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat();//表现为：早期绑定</span><br><span class="line">        System.out.println(&quot;猫吃鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hunt() &#123;</span><br><span class="line">        System.out.println(&quot;捕食耗子，天经地义&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnimalTest &#123;</span><br><span class="line">    public void showAnimal(Animal animal) &#123;</span><br><span class="line">        animal.eat();//表现为：晚期绑定</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showHunt(Huntable h) &#123;</span><br><span class="line">        h.hunt();//表现为：晚期绑定</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。其他为虚方法</p>
<p>虚拟机中调用方法的指令</p>
<ul>
<li>普通指令：<ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
</li>
<li>动态调用指令<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行。主要是为了支持动态语言的</li>
</ul>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p>
<h2 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h2><ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。如果通过则返回这个方法的直接引用，查找过程结束。如果不通过，则返回java.lang.IllegalAccessError 异常</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java堆</title>
    <url>/posts/81ff1d94/</url>
    <content><![CDATA[<p>堆也是Java内存管理的核心区域，一个JVM实例只存在一个堆内存。</p>
<p>Java堆区在JVM启动的时候即被创建。</p>
<p>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<p>“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</p>
<span id="more"></span>

<h2 id="堆结构区分"><a href="#堆结构区分" class="headerlink" title="堆结构区分"></a>堆结构区分</h2><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</p>
<ol>
<li>Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区(Permanent Space)</li>
<li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间(Meta Space)</li>
</ol>
<h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><p>存储在JVM中的Java对象可以被划分为两类:</p>
<p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速;</p>
<p>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</p>
<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）。其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间。</p>
<p>默认情况下，Eden空间和另外两个survivor空间缺省所占的比例是8:1:1。几乎所有的Java对象都是在Eden区被new出来的。</p>
<h2 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p>一般情况下，具体过程</p>
<ol>
<li>new的对象先放eden区。此区有大小限制。</li>
<li>当eden的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对eden区进行垃圾回收（MinorGC），将eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到eden区。</li>
<li>然后将eden中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：-XX:MaxTenuringThreshold&#x3D;N 进行设置</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC:Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ol>
<p>特殊情况下。<br>情况1.来了一个对象，如果eden区放不下，触发一次YGC，看能否放下。如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代。那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM。</p>
<p>情况2.如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</p>
<h2 id="堆内存设置"><a href="#堆内存设置" class="headerlink" title="堆内存设置"></a>堆内存设置</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项”-Xms”和”-Xmx”来进行设置(注意:这里设置的内存大小是指新生代与老年代的大小之和，不包括永久区或者元空间)。</p>
<ul>
<li>-Xms用于表示堆区的起始内存，等价于-XX:InitialHeapSize</li>
<li>-Xmx则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
<p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。通常会将-Xms和-Xmx两个参数配置相同的值</p>
<p>配置新生代与老年代在堆结构的占比，默认-XX:NewRatio&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p>
<p>Eden空间和另外两个survivor空间缺省所占的比例是8:1:1，可以通过选项-XX:SurvivorRatio调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8</p>
<p><strong>如何查看堆内存的使用状况？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ jps  //查看java进程</span><br><span class="line"></span><br><span class="line">$ jstat -gc pid(进程id)</span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line">SOC: S0区总共容量</span><br><span class="line">S1C: S1区总共容量</span><br><span class="line">S0U: S0区使用的量</span><br><span class="line">S1U: S1区使用的量</span><br><span class="line">EC: 伊甸园区总共容量</span><br><span class="line">EU: 伊甸园区使用的量</span><br><span class="line">OC: 老年代总共容量</span><br><span class="line">OU: 老年代使用的量</span><br></pre></td></tr></table></figure>

<h2 id="Minor-GC，Major-GC和Full-GC"><a href="#Minor-GC，Major-GC和Full-GC" class="headerlink" title="Minor GC，Major GC和Full GC"></a>Minor GC，Major GC和Full GC</h2><ol>
<li>Minor GC&#x2F;Young GC，只是新生代的垃圾收集，涉及到eden，s0，s1。eden区满的时候会触发，但是survivor区满的时候不会触发。minor gc也会引起stw，暂停用户线程。虽然他频率比较高，但是速度比较快。</li>
<li>Major GC&#x2F;Old GC，只是老年代的垃圾收集。出现major gc一般会伴随一次minor gc。他的速度比较慢，stw时间长</li>
<li>Full GC: 收集整个java堆和方法区。当老年代空间不足，方法区空间不足会触发，或者主动调用System.gc(),系统建议执行full gc，但是不是必然执行</li>
</ol>
<h3 id="GC日志示例"><a href="#GC日志示例" class="headerlink" title="GC日志示例"></a>GC日志示例</h3><p>vm中添加配置<code>-Xms9m -Xmx9m -XX:+PrintGCDetails</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试MinorGC 、 MajorGC、FullGC</span><br><span class="line"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span><br><span class="line"> * @author shkstart  shkstart@126.com</span><br><span class="line"> * @create 2020  14:19</span><br><span class="line"> */</span><br><span class="line">public class GCTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            String a = &quot;atguigu.com&quot;;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(&quot;遍历次数为：&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到输出日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), 0.0455865 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2246K-&gt;496K(2560K)] 2470K-&gt;1506K(9728K), 0.0009094 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2294K-&gt;488K(2560K)] 3305K-&gt;2210K(9728K), 0.0009568 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;488K(2560K)] 7177K-&gt;6434K(9728K), 0.0005594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 488K-&gt;472K(2560K)] 6434K-&gt;6418K(9728K), 0.0005890 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 472K-&gt;0K(2560K)] [ParOldGen: 5946K-&gt;4944K(7168K)] 6418K-&gt;4944K(9728K), [Metaspace: 3492K-&gt;3492K(1056768K)], 0.0045270 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4944K-&gt;4944K(8704K), 0.0004954 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p>在日志里面，可以看到gc信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)[PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), 0.0455865 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] </span><br><span class="line"></span><br><span class="line">[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</span><br><span class="line"></span><br><span class="line">2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</span><br></pre></td></tr></table></figure>

<h2 id="TLAB（Thread-Local-Allocation-Buffer）"><a href="#TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB（Thread Local Allocation Buffer）"></a>TLAB（Thread Local Allocation Buffer）</h2><p>线程本地分配缓存区。堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<p>因此，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内（-XX:UseTLAB设置是否开启TLAB空间），大约占百分之一。尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ol>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里v没有发生逃逸。则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除</span><br><span class="line">public void my_method() &#123;</span><br><span class="line">    V v = new V();</span><br><span class="line">    // use v</span><br><span class="line">    // ....</span><br><span class="line">    v = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码中的 StringBuffer sb 发生了逃逸，他把sb传出去了，不能在栈上分配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static StringBuffer createStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果改成,StringBuffer sb就不发生逃逸</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static StringBuffer createStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析。通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p>
<p><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。</p>
<p><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line">private static void alloc() &#123;</span><br><span class="line">    Point point = new Point(1,2);</span><br><span class="line">    System.out.println(&quot;point.x&quot; + point.x + &quot;;point.y&quot; + point.y);</span><br><span class="line">&#125;</span><br><span class="line">class Point &#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，经过标量替换后，就会变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void alloc() &#123;</span><br><span class="line">    int x = 1;</span><br><span class="line">    int y = 2;</span><br><span class="line">    System.out.println(&quot;point.x = &quot; + x + &quot;; point.y=&quot; + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就可以进行标量替换。这样就不需要创建对象了，那么就不再需要分配堆内存了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 标量替换测试</span><br><span class="line"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span><br><span class="line"> * @author shkstart  shkstart@126.com</span><br><span class="line"> * @create 2020  12:01</span><br><span class="line"> */</span><br><span class="line">public class ScalarReplace &#123;</span><br><span class="line">    public static class User &#123;</span><br><span class="line">        public int id;</span><br><span class="line">        public String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void alloc() &#123;</span><br><span class="line">        User u = new User();//未发生逃逸</span><br><span class="line">        u.id = 5;</span><br><span class="line">        u.name = &quot;www.atguigu.com&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费的时间为： &quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开的情况下”-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations”，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花费的时间为： 6 ms</span><br></pre></td></tr></table></figure>
<p>关闭的情况下”-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations”，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  25600K-&gt;880K(98304K), 0.0012658 secs]</span><br><span class="line">[GC (Allocation Failure)  26480K-&gt;832K(98304K), 0.0012124 secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;784K(98304K), 0.0009719 secs]</span><br><span class="line">[GC (Allocation Failure)  26384K-&gt;832K(98304K), 0.0009071 secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;768K(98304K), 0.0010643 secs]</span><br><span class="line">[GC (Allocation Failure)  26368K-&gt;824K(101376K), 0.0012354 secs]</span><br><span class="line">[GC (Allocation Failure)  32568K-&gt;712K(100864K), 0.0011291 secs]</span><br><span class="line">[GC (Allocation Failure)  32456K-&gt;712K(100864K), 0.0006368 secs]</span><br><span class="line">花费的时间为： 99 ms</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java方法区</title>
    <url>/posts/bbfc6654/</url>
    <content><![CDATA[<p>方法区主要是存放的是 Class，而堆中主要存放的是实例化的对象。</p>
<p>方法区也是线程共享的区域。多个线程同时加载同一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次</p>
<p>方法区在JVM启动的时候被创建，关闭JVM就会释放这个区域的内存</p>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误。java.lang.OutofMemoryError:PermGen space或者java.lang.OutOfMemoryError:Metaspace</p>
<p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</p>
<span id="more"></span>

<h2 id="HotSpot方法区演变"><a href="#HotSpot方法区演变" class="headerlink" title="HotSpot方法区演变"></a>HotSpot方法区演变</h2><p>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></p>
<h3 id="JDK7之前"><a href="#JDK7之前" class="headerlink" title="JDK7之前"></a>JDK7之前</h3><p>通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M</p>
<h3 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定</p>
<p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值</p>
<p>方法区OOM例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OOMTest extends ClassLoader &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            OOMTest test = new OOMTest();</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                //创建ClassWriter对象，用于生成类的二进制字节码</span><br><span class="line">                ClassWriter classWriter = new ClassWriter(0);</span><br><span class="line">                //指明版本号，修饰符，类名，包名，父类，接口</span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null);</span><br><span class="line">                //返回byte[]</span><br><span class="line">                byte[] code = classWriter.toByteArray();</span><br><span class="line">                //类的加载</span><br><span class="line">                test.defineClass(&quot;Class&quot; + i, code, 0, code.length);//Class对象</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用默认的 JVM 参数，元空间不设置上限，得到结果10000。但是设置元空间上限-XX:MetaspaceSize&#x3D;10m -XX:MaxMetaspaceSize&#x3D;10m。<br>则报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8531</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">	at com.atguigu.java.OOMTest.main(OOMTest.java:29)</span><br></pre></td></tr></table></figure>

<h2 id="方法区存储内容"><a href="#方法区存储内容" class="headerlink" title="方法区存储内容"></a>方法区存储内容</h2><p><strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等</strong></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：这个类型的完整有效名称，直接父类的完整有效名，修饰符，直接接口的一个有序列表</p>
<h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序，域的相关信息包括：域名称，域类型，域修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int num;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">private static java.lang.String str;</span><br><span class="line">  descriptor: Ljava/lang/String;</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure>
<p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MethodAreaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Order order = null;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Order &#123;</span><br><span class="line">    public static int count = 1;</span><br><span class="line">    public static final int number = 2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使我们把order设置为null，也不会出现空指针异常</p>
<p>如果是static final修饰的全局常量在编译的时候就会被分配了，已经写死在字节码文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final int number;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: int 2 </span><br></pre></td></tr></table></figure>
<h3 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h3><p>方法名称，返回类型，参数的数量和类型，修饰符，字节码，操作数栈、局部变量表及大小，异常表。</p>
<p>如这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test1();</span><br><span class="line">    descriptor: ()V         // 表示方法返回值类型为 void</span><br><span class="line">    flags: ACC_PUBLIC      //方法权限修饰符为 public</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1       // 操作数栈深度为 3，局部变量个数为 2 个</span><br><span class="line">         0: bipush        20</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         9: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        18: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        28: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 17: 0</span><br><span class="line">        line 18: 3</span><br><span class="line">        line 19: 28</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      29     0  this   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            3      26     1 count   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p><strong>静态对象实体始终是分配在堆中。</strong> 但是指向实体的变量不是</p>
<p>JDK1.6及以前，静态变量引用存储在永久代上。但是JDK1.7，字符串常量池，静态变量移除，保存在堆中。</p>
<p><strong>为什么要调整位置？</strong><br>因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。当我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>另外就是类卸载，要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ol>
<li>该类所有的实例都已经被回收</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的实例化内存布局和访问定位</title>
    <url>/posts/2f811178/</url>
    <content><![CDATA[<h1 id="对象创建步骤"><a href="#对象创建步骤" class="headerlink" title="对象创建步骤"></a>对象创建步骤</h1><ol>
<li>判断对象对应的类是否加载、链接、初始化</li>
<li>为对象分配内存，计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li>
<li>处理并发问题</li>
<li>初始化分配到的空间，所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li>
<li>设置对象的对象头,将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中</li>
<li>执行init方法进行初始化</li>
</ol>
<span id="more"></span>

<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>包含两部分，运行时元数据和类型指针</p>
<p>运行时元数据Mark Word:包含哈希值，GC分代年龄，锁状态标志，偏向线程ID，偏向时间戳。他在32位jvm中的长度为32bit。MarkWord被设计成一个非固定的数据结构，以便在极小的空间存储尽量多的信息</p>
<p><img src="/images/20190612142936955.png" alt="mark word"></p>
<p>类型指针: 指向方法区，区分对象的类型。</p>
<h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>对象真正存储的信息，有指向常量池，或者堆中的其他实例</p>
<h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>占位的作用。</p>
<h1 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h1><p>有句柄访问和直接访问两种方式。</p>
<h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>在堆空间中开辟了一块空间作为句柄池，句柄池本身也占空间。引用指向句柄，句柄包含指向实例数据的指针和指向类型的执行。通过两次指针访问才能访问到堆中的对象，效率低</p>
<h2 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h2><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。hotspot采用这种方式。对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java字符串</title>
    <url>/posts/ba15c230/</url>
    <content><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>String类被声明为final的，不可被继承。它实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小。<br>在jdk8及以前内部定义了final char value[]用于存储字符串数据。JDK9时改为byte[]。</p>
<p>String是不可变的字符序列，<strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p>
<span id="more"></span>
<h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>Java 6及以前，字符串常量池存放在永久代。</p>
<p>Java 7中 ，有永久代，Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p>
<p>Jdk1.8及之后： 无永久代，<strong>运行时常量池在元空间，字符串常量池里依然在堆里</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * jdk8中：</span><br><span class="line"> * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span><br><span class="line"> */</span><br><span class="line">public class StringTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //使用Set保持着常量池引用，避免full gc回收常量池行为</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;String&gt;();</span><br><span class="line">        //在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span><br><span class="line">        short i = 0;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报错,证明字符串常量池是在堆中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.HashMap.resize(HashMap.java:703)</span><br><span class="line">	at java.util.HashMap.putVal(HashMap.java:662)</span><br><span class="line">	at java.util.HashMap.put(HashMap.java:611)</span><br><span class="line">	at java.util.HashSet.add(HashSet.java:219)</span><br><span class="line">	at com.atguigu.java.StringTest3.main(StringTest3.java:22)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure>

<p>字符串常量池是不会存储相同内容的字符串的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;1&quot;);</span><br><span class="line">System.out.println(&quot;2&quot;);</span><br><span class="line">System.out.println(&quot;3&quot;);</span><br><span class="line">System.out.println(&quot;1&quot;);</span><br><span class="line">System.out.println(&quot;2&quot;);</span><br></pre></td></tr></table></figure>
<p>字符串常量池只会新增三个字符串常量</p>
<h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br><span class="line">String s2 = &quot;abc&quot;; </span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>这种代码，s1会在编译器优化，将 “a” + “b” + “c” 优化成了 “abc”，所以相等。</p>
<p>但是如果加号前后有变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = &quot;a&quot;;</span><br><span class="line">String s2 = &quot;b&quot;;</span><br><span class="line">String s3 = &quot;ab&quot;;</span><br><span class="line">String s4 = s1 + s2;</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>
<p>则s1+s2从字节码的角度而言，约等于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder s = new StringBuilder();</span><br><span class="line">s.append(&quot;a&quot;)</span><br><span class="line">s.append(&quot;b&quot;)</span><br><span class="line">s.toString()   //约等于 new String(&quot;ab&quot;)</span><br></pre></td></tr></table></figure>
<p>s3指向字符串常量池的字符串常量ab，s4指向一个string对象。</p>
<h2 id="append与-对比"><a href="#append与-对比" class="headerlink" title="append与+对比"></a>append与+对比</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method1(int highLevel)&#123;</span><br><span class="line">    String src = &quot;&quot;;</span><br><span class="line">    for(int i = 0;i &lt; highLevel;i++)&#123;</span><br><span class="line">        src = src + &quot;a&quot;;//每次循环都会创建一个StringBuilder、String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void method2(int highLevel)&#123;</span><br><span class="line">    //只需要创建一个StringBuilder</span><br><span class="line">    StringBuilder src = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src.append(&quot;a&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然method1中，创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大。如果进行GC，还需要花费额外的时间</p>
<h1 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String() 的说明"></a>new String() 的说明</h1><p><strong>new String(“ab”)会创建几个对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = new String(&quot;ab&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/String&gt;            -&gt; 在堆中创建了一个 String 对象</span><br><span class="line">3 dup</span><br><span class="line">4 ldc #3 &lt;ab&gt;                          -&gt; 在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</span><br><span class="line">6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>
<p>所以是两个对象。</p>
<p><strong>new String(“a”) + new String(“b”) 会创建几个对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*  对象1：new StringBuilder()</span><br><span class="line">*  对象2： new String(&quot;a&quot;)</span><br><span class="line">*  对象3： 常量池中的&quot;a&quot;</span><br><span class="line">*  对象4： new String(&quot;b&quot;)</span><br><span class="line">*  对象5： 常量池中的&quot;b&quot;</span><br><span class="line">*  对象6 ：StringBuilder的toString()</span><br><span class="line">*         强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span><br></pre></td></tr></table></figure>

<h1 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h1><p>在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址</p>
<p>在Java 6以前，字符串常量池存放在永久代。但是Java 7 之后呢，由于字符串常量池放在了堆中，执行 String.intern() 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存空间。</p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s = new String(&quot;1&quot;);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = &quot;1&quot;;</span><br><span class="line">    System.out.println(s == s2);        // false:  s是String对象，s2固定指向字符串常量池中字面量1</span><br><span class="line"></span><br><span class="line">    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);  //字符串常量池中 没有11</span><br><span class="line">    s3.intern();                     //在java7后字符串常量池中，存放的是s3的地址</span><br><span class="line">    String s4 = &quot;11&quot;;</span><br><span class="line">    System.out.println(s3 == s4);    // java6:false java7:true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;); </span><br><span class="line">    String s4 = &quot;11&quot;;</span><br><span class="line">    s3.intern();                     </span><br><span class="line">    System.out.println(s3 == s4);    //false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 = new String(&quot;ab&quot;);//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span><br><span class="line"></span><br><span class="line">    s1.intern();</span><br><span class="line">    String s2 = &quot;ab&quot;;</span><br><span class="line">    System.out.println(s1 == s2);//false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class StringExer2 &#123;</span><br><span class="line">    // 对象内存地址可以使用System.identityHashCode(object)方法获取</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);//执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        s1.intern();</span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        String s2 = &quot;ab&quot;;</span><br><span class="line">        System.out.println(System.identityHashCode(s2));</span><br><span class="line">        System.out.println(s1 == s2); // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="intern-执行效率"><a href="#intern-执行效率" class="headerlink" title="intern 执行效率"></a>intern 执行效率</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用intern()测试执行效率：空间使用上</span><br><span class="line"> *</span><br><span class="line"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class StringIntern2 &#123;</span><br><span class="line">    static final int MAX_COUNT = 1000 * 10000;</span><br><span class="line">    static final String[] arr = new String[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] data = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line"></span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span><br><span class="line">            arr[i] = new String(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费的时间为：&quot; + (end - start));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高。而使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java垃圾回收</title>
    <url>/posts/1265ab80/</url>
    <content><![CDATA[<p>垃圾是指在运行程序中没有任何指针指向的对象，如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。<br>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。</p>
<p>java的垃圾收集器主要是可以对年轻代回收，当然也可以对老年代回收，甚至是全栈和方法区的回收。</p>
<span id="more"></span>

<h1 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h1><h2 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h2><p>首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。<br>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</p>
<h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3><p>是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链。如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。<br><strong>哪些可以作为GCRoots</strong></p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
<h2 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>如果没有标记为可达对象，则将其回收。这里，所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。该算法效率不算高，在进行GC的时候，需要停止整个应用程序，用户体验较差，同时碎片化严重</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。<br>新生代里面from和to区就用到了复制算法。<br>实现简单，运行高效。不会出现“碎片”问题。但是需要两倍的内存空间。然后他还需要维护对象引用关系</p>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>和标记清除算法一样，从根节点开始标记所有被引用对象。然后，将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>对比三种清除阶段的算法，有各自的优缺点<br>总结:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">标记清除</th>
<th align="center">复制算法</th>
<th align="center">标记整理</th>
</tr>
</thead>
<tbody><tr>
<td align="center">速率</td>
<td align="center">中等</td>
<td align="center">快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">空间开销</td>
<td align="center">少</td>
<td align="center">2倍空间</td>
<td align="center">少</td>
</tr>
<tr>
<td align="center">移动对象</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<p>没有最好的算法，只有最合适的算法。分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。<br>年轻代:对象生命周期短、存活率低，回收频繁。这种情况复制算法的回收整理，速度是最快的。<br>老年代:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java对象的生命周期</title>
    <url>/posts/e3104623/</url>
    <content><![CDATA[<p>java对象的生命周期可以分为7个阶段：创建阶段、使用阶段、不可视阶段、不可达阶段、可收集阶段、终结阶段、释放阶段。</p>
<span id="more"></span>

<h2 id="不可视阶段"><a href="#不可视阶段" class="headerlink" title="不可视阶段"></a>不可视阶段</h2><p>对象使用已经结束，并且在其可视区域不再使用。此时应主动将对象置为null，有助于JVM及时发现该垃圾对象。</p>
<h2 id="不可达阶段"><a href="#不可达阶段" class="headerlink" title="不可达阶段"></a>不可达阶段</h2><p>JVM通过可达性分析，从root集合中找不到该对象直接或间接的强引用。此时该对象被标注为GC回收的预备对象，但没有被直接回收</p>
<h2 id="可收集阶段"><a href="#可收集阶段" class="headerlink" title="可收集阶段"></a>可收集阶段</h2><p>GC已经发现该对象不可达。这里涉及到一个方法finalize</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。垃圾回收此对象之前，总会先调用这个对象的finalize()方法，该方法可以在子类中重写。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<p><strong>永远不要主动调用某个对象的finalize()方法。</strong>该方法的执行时间是没有保障的，它完全由GC线程决定。一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环。</p>
<p>finalize()方法对应了一个finalize线程，因为finalize线程优先级比较低，即使主动调用该方法，也不会因此就直接进行回收。</p>
<p>判定一个对象是否可回收，至少要经历两次标记过程:</p>
<ol>
<li>对象到GC Roots没有引用链，则进行第一次标记。</li>
<li>判断此对象是否有必要执行finalize()方法</li>
</ol>
<ul>
<li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li>
<li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</li>
</ul>
<h2 id="终结阶段"><a href="#终结阶段" class="headerlink" title="终结阶段"></a>终结阶段</h2><p>finalize方法已经被执行</p>
<h2 id="释放阶段"><a href="#释放阶段" class="headerlink" title="释放阶段"></a>释放阶段</h2><p>对象空间已经被重用</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
